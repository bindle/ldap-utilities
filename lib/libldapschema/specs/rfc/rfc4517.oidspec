{
   // RFC 4512                      LDAP Models                      June 2006
   //
   // 4.1.2.  Attribute Types
   //
   //    Attribute Type definitions are written according to the ABNF:
   //
   //      AttributeTypeDescription = LPAREN WSP
   //          numericoid                    ; object identifier
   //          [ SP "NAME" SP qdescrs ]      ; short names (descriptors)
   //          [ SP "DESC" SP qdstring ]     ; description
   //          [ SP "OBSOLETE" ]             ; not active
   //          [ SP "SUP" SP oid ]           ; supertype
   //          [ SP "EQUALITY" SP oid ]      ; equality matching rule
   //          [ SP "ORDERING" SP oid ]      ; ordering matching rule
   //          [ SP "SUBSTR" SP oid ]        ; substrings matching rule
   //          [ SP "SYNTAX" SP noidlen ]    ; value syntax
   //          [ SP "SINGLE-VALUE" ]         ; single-value
   //          [ SP "COLLECTIVE" ]           ; collective
   //          [ SP "NO-USER-MODIFICATION" ] ; not user modifiable
   //          [ SP "USAGE" SP usage ]       ; usage
   //          extensions WSP RPAREN         ; extensions
   //
   //      usage = "userApplications"     /  ; user
   //              "directoryOperation"   /  ; directory operational
   //              "distributedOperation" /  ; DSA-shared operational
   //              "dSAOperation"            ; DSA-specific operational
   //
   //    where:
   //      <numericoid> is object identifier assigned to this attribute type;
   //      NAME <qdescrs> are short names (descriptors) identifying this
   //          attribute type;
   //      DESC <qdstring> is a short descriptive string;
   //      OBSOLETE indicates this attribute type is not active;
   //      SUP oid specifies the direct supertype of this type;
   //      EQUALITY, ORDERING, and SUBSTR provide the oid of the equality,
   //          ordering, and substrings matching rules, respectively;
   //      SYNTAX identifies value syntax by object identifier and may suggest
   //          a minimum upper bound;
   //      SINGLE-VALUE indicates attributes of this type are restricted to a
   //          single value;
   //      COLLECTIVE indicates this attribute type is collective
   //          [X.501][RFC3671];
   //      NO-USER-MODIFICATION indicates this attribute type is not user
   //          modifiable;
   //      USAGE indicates the application of this attribute type; and
   //      <extensions> describe extensions.
   //         
   //    Each attribute type description must contain at least one of the SUP
   //    or SYNTAX fields.  If no SYNTAX field is provided, the attribute type
   //    description takes its value from the supertype.
   //         
   //    If SUP field is provided, the EQUALITY, ORDERING, and SUBSTRING
   //    fields, if not specified, take their value from the supertype.
   //         
   //    Usage of userApplications, the default, indicates that attributes of
   //    this type represent user information.  That is, they are user
   //    attributes.
   //         
   //    A usage of directoryOperation, distributedOperation, or dSAOperation
   //    indicates that attributes of this type represent operational and/or
   //    administrative information.  That is, they are operational
   //    attributes.
   //             
   //    directoryOperation usage indicates that the attribute of this type is
   //    a directory operational attribute.  distributedOperation usage
   //    indicates that the attribute of this type is a DSA-shared usage
   //    operational attribute.  dSAOperation usage indicates that the
   //    attribute of this type is a DSA-specific operational attribute.
   //     
   //    COLLECTIVE requires usage userApplications.  Use of collective
   //    attribute types in LDAP is discussed in [RFC3671].
   //     
   //    NO-USER-MODIFICATION requires an operational usage.
   //
   //    Note that the <AttributeTypeDescription> does not list the matching
   //    rules that can be used with that attribute type in an extensibleMatch
   //    search filter [RFC4511].  This is done using the 'matchingRuleUse'
   //    attribute described in Section 4.1.4.
   //
   //    This document refines the schema description of X.501 by requiring
   //    that the SYNTAX field in an <AttributeTypeDescription> be a string
   //    representation of an object identifier for the LDAP string syntax
   //    definition, with an optional indication of the suggested minimum
   //    bound of a value of this attribute.
   //
   //    A suggested minimum upper bound on the number of characters in a
   //    value with a string-based syntax, or the number of bytes in a value
   //    for all other syntaxes, may be indicated by appending this bound
   //    count inside of curly braces following the syntax's OBJECT IDENTIFIER
   //    in an Attribute Type Description.  This bound is not part of the
   //    syntax name itself.  For instance, "1.3.6.4.1.1466.0{64}" suggests
   //    that server implementations should allow a string to be 64 characters
   //    long, although they may allow longer strings.  Note that a single
   //    character of the Directory String syntax may be encoded in more than
   //    one octet since UTF-8 [RFC3629] is a variable-length encoding.
   //
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.1.  Attribute Type Description
   //
   //    A value of the Attribute Type Description syntax is the definition of
   //    an attribute type.  The LDAP-specific encoding of a value of this
   //    syntax is defined by the <AttributeTypeDescription> rule in
   //    [RFC4512].
   //
   //       For example, the following definition of the createTimestamp
   //       attribute type from [RFC4512] is also a value of the Attribute
   //       Type Description syntax.  (Note: Line breaks have been added for
   //       readability; they are not part of the value when transferred in
   //       protocol.)
   //
   //          ( 2.5.18.1 NAME 'createTimestamp'
   //             EQUALITY generalizedTimeMatch
   //             ORDERING generalizedTimeOrderingMatch
   //             SYNTAX 1.3.6.1.4.1.1466.115.121.1.24
   //             SINGLE-VALUE NO-USER-MODIFICATION
   //             USAGE directoryOperation )
   //
   //    The LDAP definition for the Attribute Type Description syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.3 DESC 'Attribute Type Description' )
   //
   //    This syntax corresponds to the AttributeTypeDescription ASN.1 type
   //    from [X.501].
   //
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.3",
   .name          =  "AttributeTypeDescription",
   .desc          =  "Attribute Type Description",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF | LDAPSCHEMA_O_SCHEMA_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.3 DESC 'Attribute Type Description' )",
   .abnf          =  "AttributeTypeDescription = LPAREN WSP\n"
                     "    numericoid                    ; object identifier\n"
                     "    [ SP \"NAME\" SP qdescrs ]      ; short names (descriptors)\n"
                     "    [ SP \"DESC\" SP qdstring ]     ; description\n"
                     "    [ SP \"OBSOLETE\" ]             ; not active\n"
                     "    [ SP \"SUP\" SP oid ]           ; supertype\n"
                     "    [ SP \"EQUALITY\" SP oid ]      ; equality matching rule\n"
                     "    [ SP \"ORDERING\" SP oid ]      ; ordering matching rule\n"
                     "    [ SP \"SUBSTR\" SP oid ]        ; substrings matching rule\n"
                     "    [ SP \"SYNTAX\" SP noidlen ]    ; value syntax\n"
                     "    [ SP \"SINGLE-VALUE\" ]         ; single-value\n"
                     "    [ SP \"COLLECTIVE\" ]           ; collective\n"
                     "    [ SP \"NO-USER-MODIFICATION\" ] ; not user modifiable\n"
                     "    [ SP \"USAGE\" SP usage ]       ; usage\n"
                     "    extensions WSP RPAREN         ; extensions\n"
                     "\n"
                     "usage = \"userApplications\"     /  ; user\n"
                     "        \"directoryOperation\"   /  ; directory operational\n"
                     "        \"distributedOperation\" /  ; DSA-shared operational\n"
                     "        \"dSAOperation\"            ; DSA-specific operational\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.1",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "( 2.5.18.1 NAME 'createTimestamp' EQUALITY generalizedTimeMatch ORDERING generalizedTimeOrderingMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )",
                        NULL,
                     },
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.2.  Bit String
   //
   //    A value of the Bit String syntax is a sequence of binary digits.  The
   //    LDAP-specific encoding of a value of this syntax is defined by the
   //    following ABNF:
   //
   //       BitString    = SQUOTE *binary-digit SQUOTE "B"
   //       binary-digit = "0" / "1"
   //
   //    The <SQUOTE> rule is defined in [RFC4512].
   //
   //       Example:
   //          '0101111101'B
   //
   //    The LDAP definition for the Bit String syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.6 DESC 'Bit String' )
   //
   //    This syntax corresponds to the BIT STRING ASN.1 type from [ASN.1].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.6",
   .name          =  "BitString",
   .desc          =  "Bit String",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.6 DESC 'Bit String' )",
   .abnf          =  "BitString    = SQUOTE *binary-digit SQUOTE \"B\"\n"
                     "SQUOTE  = %x27 ; single quote (\"'\")\n"
                     "binary-digit = \"0\" / \"1\"\n",
   .re_posix      =  "^('[01]{1,}'B)$",
   .re_pcre       =  "^('[01]+'B)$",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.2",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "'0101111101'B",
                        NULL,
                     },
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.3.  Boolean
   //
   //    A value of the Boolean syntax is one of the Boolean values, true or
   //    false.  The LDAP-specific encoding of a value of this syntax is
   //    defined by the following ABNF:
   //
   //       Boolean = "TRUE" / "FALSE"
   //
   //    The LDAP definition for the Boolean syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.7 DESC 'Boolean' )
   //
   //    This syntax corresponds to the BOOLEAN ASN.1 type from [ASN.1].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.7",
   .name          =  "Boolean",
   .desc          =  "Boolean",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.7 DESC 'Boolean' )",
   .abnf          =  "Boolean = \"TRUE\" / \"FALSE\"",
   .re_posix      =  "^(TRUE|FALSE)$",
   .re_pcre       =  "^(TRUE|FALSE)$",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.3",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "TRUE",
                        "FALSE",
                        NULL,
                     },
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.4.  Country String
   //
   //    A value of the Country String syntax is one of the two-character
   //    codes from ISO 3166 [ISO3166] for representing a country.  The LDAP-
   //    specific encoding of a value of this syntax is defined by the
   //    following ABNF:
   //
   //       CountryString  = 2(PrintableCharacter)
   //
   //    The <PrintableCharacter> rule is defined in Section 3.2.
   //
   //       Examples:
   //
   //          US
   //          AU
   //
   //    The LDAP definition for the Country String syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.11 DESC 'Country String' )
   //
   //    This syntax corresponds to the following ASN.1 type from [X.520]:
   //
   //       PrintableString (SIZE (2)) -- ISO 3166 codes only
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.11",
   .name          =  "CountryString",
   .desc          =  "Country String",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.11 DESC 'Country String' )",
   .abnf          =  "CountryString  = 2(PrintableCharacter)\n"
                     "PrintableCharacter = ALPHA / DIGIT / SQUOTE / LPAREN / RPAREN /\n"
                     "      PLUS / COMMA / HYPHEN / DOT / EQUALS / SLASH / COLON /\n"
                     "      QUESTION / SPACE\n",
   .re_posix      =  "^([-'()+,.=/:? a-zA-Z0-9]{2,2})$",
   .re_pcre       =  "^([-'()+,.=/:? a-zA-Z0-9]{2,2})$",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.4",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "US",
                        "AU",
                        NULL,
                     },
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.5.  Delivery Method
   //
   //    A value of the Delivery Method syntax is a sequence of items that
   //    indicate, in preference order, the service(s) by which an entity is
   //    willing and/or capable of receiving messages.  The LDAP-specific
   //    encoding of a value of this syntax is defined by the following ABNF:
   //
   //       DeliveryMethod = pdm *( WSP DOLLAR WSP pdm )
   //
   //       pdm = "any" / "mhs" / "physical" / "telex" / "teletex" /
   //             "g3fax" / "g4fax" / "ia5" / "videotex" / "telephone"
   //
   //    The <WSP> and <DOLLAR> rules are defined in [RFC4512].
   //
   //       Example:
   //          telephone $ videotex
   //
   //    The LDAP definition for the Delivery Method syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.14 DESC 'Delivery Method' )
   //
   //    This syntax corresponds to the following ASN.1 type from [X.520]:
   //
   //       SEQUENCE OF INTEGER {
   //           any-delivery-method     (0),
   //           mhs-delivery            (1),
   //           physical-delivery       (2),
   //           telex-delivery          (3),
   //           teletex-delivery        (4),
   //           g3-facsimile-delivery   (5),
   //           g4-facsimile-delivery   (6),
   //           ia5-terminal-delivery   (7),
   //           videotex-delivery       (8),
   //           telephone-delivery      (9) }
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.14",
   .name          =  "DeliveryMethod",
   .desc          =  "Delivery Method",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.14 DESC 'Delivery Method' )",
   .abnf          =  "DeliveryMethod = pdm *( WSP DOLLAR WSP pdm )\n"
                     "\n"
                     "pdm     = \"any\" / \"mhs\" / \"physical\" / \"telex\" / \"teletex\" /\n"
                     "          \"g3fax\" / \"g4fax\" / \"ia5\" / \"videotex\" / \"telephone\"\n"
                     "\n"
                     "WSP     = 0*SPACE  ; zero or more \" \"\n"
                     "DOLLAR  = %x24 ; dollar sign (\"$\")\n",
   .re_posix      =  "^((any|mhs|physical|telex|teletex|g3fax|g4fax|ia5|videotex|videotex)([ ]{0,}[$][ ]{0,}(any|mhs|physical|telex|teletex|g3fax|g4fax|ia5|videotex|videotex)){0,})$",
   .re_pcre       =  "^((any|mhs|physical|telex|teletex|g3fax|g4fax|ia5|videotex|videotex)([ ]*[$][ ]*(any|mhs|physical|telex|teletex|g3fax|g4fax|ia5|videotex|videotex))*)$",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.5",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "any",
                        "physical $ telephone",
                        NULL,
                     },
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.6.  Directory String
   //
   //    A value of the Directory String syntax is a string of one or more
   //    arbitrary characters from the Universal Character Set (UCS) [UCS].  A
   //    zero-length character string is not permitted.  The LDAP-specific
   //    encoding of a value of this syntax is the UTF-8 encoding [RFC3629] of
   //    the character string.  Such encodings conform to the following ABNF:
   //
   //       DirectoryString = 1*UTF8
   //
   //    The <UTF8> rule is defined in [RFC4512].
   //
   //       Example:
   //          This is a value of Directory String containing #!%#@.
   //
   //    Servers and clients MUST be prepared to receive arbitrary UCS code
   //    points, including code points outside the range of printable ASCII
   //    and code points not presently assigned to any character.
   //
   //    Attribute type definitions using the Directory String syntax should
   //    not restrict the format of Directory String values, e.g., by
   //    requiring that the character string conforms to specific patterns
   //    described by ABNF.  A new syntax should be defined in such cases.
   //
   //    The LDAP definition for the Directory String syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.15 DESC 'Directory String' )
   //
   //    This syntax corresponds to the DirectoryString parameterized ASN.1
   //    type from [X.520].
   //
   //    The DirectoryString ASN.1 type allows a choice between the
   //    TeletexString, PrintableString, or UniversalString ASN.1 types from
   //    [ASN.1].  However, note that the chosen alternative is not indicated
   //    in the LDAP-specific encoding of a Directory String value.
   //
   //    Implementations that convert Directory String values from the LDAP-
   //    specific encoding to the BER encoding used by X.500 must choose an
   //    alternative that permits the particular characters in the string and
   //    must convert the characters from the UTF-8 encoding into the
   //    character encoding of the chosen alternative.  When converting
   //    Directory String values from the BER encoding to the LDAP-specific
   //    encoding, the characters must be converted from the character
   //    encoding of the chosen alternative into the UTF-8 encoding.  These
   //    conversions SHOULD be done in a manner consistent with the Transcode
   //    step of the string preparation algorithms [RFC4518] for LDAP.
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.15",
   .name          =  "DirectoryString",
   .desc          =  "Directory String",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_UTF8,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.15 DESC 'Directory String' )",
   .abnf          =  "DirectoryString = 1*UTF8\n"
                     "\n"
                     "UTF8    = UTF1 / UTFMB\n"
                     "UTFMB   = UTF2 / UTF3 / UTF4\n"
                     "UTF0    = %x80-BF\n"
                     "UTF1    = %x00-7F\n"
                     "UTF2    = %xC2-DF UTF0\n"
                     "UTF3    = %xE0 %xA0-BF UTF0 / %xE1-EC 2(UTF0) /\n"
                     "          %xED %x80-9F UTF0 / %xEE-EF 2(UTF0)\n"
                     "UTF4    = %xF0 %x90-BF 2(UTF0) / %xF1-F3 3(UTF0) /\n"
                      "         %xF4 %x80-8F 2(UTF0)\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.6",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "This is a value of Directory String containing #!%#@.",
                        NULL,
                     },
};



{
   //
   // RFC 4512                      LDAP Models                      June 2006
   //
   // 4.1.6.  DIT Content Rules
   //
   //    A DIT content rule is a "rule governing the content of entries of a
   //    particular structural object class" [X.501].
   //
   //    For DIT entries of a particular structural object class, a DIT
   //    content rule specifies which auxiliary object classes the entries are
   //    allowed to belong to and which additional attributes (by type) are
   //    required, allowed, or not allowed to appear in the entries.
   //
   //    The list of precluded attributes cannot include any attribute listed
   //    as mandatory in the rule, the structural object class, or any of the
   //    allowed auxiliary object classes.
   // 
   //    Each content rule is identified by the object identifier, as well as
   //    any short names (descriptors), of the structural object class it
   //    applies to.
   //
   //    An entry may only belong to auxiliary object classes listed in the
   //    governing content rule.
   //
   //    An entry must contain all attributes required by the object classes
   //    the entry belongs to as well as all attributes required by the
   //    governing content rule.
   //
   //    An entry may contain any non-precluded attributes allowed by the
   //    object classes the entry belongs to as well as all attributes allowed
   //    by the governing content rule.
   //
   //    An entry cannot include any attribute precluded by the governing
   //    content rule.
   //
   //    An entry is governed by (if present and active in the subschema) the
   //    DIT content rule that applies to the structural object class of the
   //    entry (see Section 2.4.2).  If no active rule is present for the
   //    entry's structural object class, the entry's content is governed by
   //    the structural object class (and possibly other aspects of user and
   //    system schema).  DIT content rules for superclasses of the structural
   //    object class of an entry are not applicable to that entry.
   //
   //    DIT content rule descriptions are written according to the ABNF:
   // 
   //      DITContentRuleDescription = LPAREN WSP
   //          numericoid                 ; object identifier
   //          [ SP "NAME" SP qdescrs ]   ; short names (descriptors)
   //          [ SP "DESC" SP qdstring ]  ; description
   //          [ SP "OBSOLETE" ]          ; not active
   //          [ SP "AUX" SP oids ]       ; auxiliary object classes
   //          [ SP "MUST" SP oids ]      ; attribute types
   //          [ SP "MAY" SP oids ]       ; attribute types
   //          [ SP "NOT" SP oids ]       ; attribute types
   //          extensions WSP RPAREN      ; extensions
   //   
   //    where:
   //      <numericoid> is the object identifier of the structural object
   //          class associated with this DIT content rule;
   //      NAME <qdescrs> are short names (descriptors) identifying this DIT
   //          content rule;
   //      DESC <qdstring> is a short descriptive string;
   //      OBSOLETE indicates this DIT content rule use is not active;
   //      AUX specifies a list of auxiliary object classes that entries
   //          subject to this DIT content rule may belong to;
   //
   //     MUST, MAY, and NOT specify lists of attribute types that are
   //          required, allowed, or precluded, respectively, from appearing
   //          in entries subject to this DIT content rule; and
   //      <extensions> describe extensions.
   //
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.7.  DIT Content Rule Description
   //
   //    A value of the DIT Content Rule Description syntax is the definition
   //    of a DIT (Directory Information Tree) content rule.  The LDAP-
   //    specific encoding of a value of this syntax is defined by the
   //    <DITContentRuleDescription> rule in [RFC4512].
   //
   //       Example:
   //          ( 2.5.6.4 DESC 'content rule for organization'
   //             NOT ( x121Address $ telexNumber ) )
   //
   //       Note: A line break has been added for readability; it is not part
   //       of the value.
   //
   //    The LDAP definition for the DIT Content Rule Description syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.16
   //          DESC 'DIT Content Rule Description' )
   //
   //    This syntax corresponds to the DITContentRuleDescription ASN.1 type
   //    from [X.501].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.16",
   .name          =  "DITContentRuleDescription",
   .desc          =  "DIT Content Rule Description",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF | LDAPSCHEMA_O_SCHEMA_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.16 DESC 'DIT Content Rule Description' )",
   .abnf          =  "DITContentRuleDescription = LPAREN WSP\n"
                     "    numericoid                 ; object identifier\n"
                     "    [ SP \"NAME\" SP qdescrs ]   ; short names (descriptors)\n"
                     "    [ SP \"DESC\" SP qdstring ]  ; description\n"
                     "    [ SP \"OBSOLETE\" ]          ; not active\n"
                     "    [ SP \"AUX\" SP oids ]       ; auxiliary object classes\n"
                     "    [ SP \"MUST\" SP oids ]      ; attribute types\n"
                     "    [ SP \"MAY\" SP oids ]       ; attribute types\n"
                     "    [ SP \"NOT\" SP oids ]       ; attribute types\n"
                     "    extensions WSP RPAREN      ; extensions\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.7",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4512                      LDAP Models                      June 2006
   //
   // 4.1.7.1.  DIT Structure Rules
   //
   //    A DIT structure rule is a "rule governing the structure of the DIT by
   //    specifying a permitted superior to subordinate entry relationship.  A
   //    structure rule relates a name form, and therefore a structural object
   //    class, to superior structure rules.  This permits entries of the
   //    structural object class identified by the name form to exist in the
   //    DIT as subordinates to entries governed by the indicated superior
   //    structure rules" [X.501].
   //
   //    DIT structure rule descriptions are written according to the ABNF:
   //
   //      DITStructureRuleDescription = LPAREN WSP
   //          ruleid                     ; rule identifier
   //          [ SP "NAME" SP qdescrs ]   ; short names (descriptors)
   //          [ SP "DESC" SP qdstring ]  ; description
   //          [ SP "OBSOLETE" ]          ; not active
   //          SP "FORM" SP oid           ; NameForm
   //          [ SP "SUP" ruleids ]       ; superior rules
   //          extensions WSP RPAREN      ; extensions
   //
   //      ruleids = ruleid / ( LPAREN WSP ruleidlist WSP RPAREN )
   //      ruleidlist = ruleid *( SP ruleid )
   //      ruleid = number
   //
   //    where:
   //      <ruleid> is the rule identifier of this DIT structure rule;
   //      NAME <qdescrs> are short names (descriptors) identifying this DIT
   //          structure rule;
   //      DESC <qdstring> is a short descriptive string;
   //      OBSOLETE indicates this DIT structure rule use is not active;
   //      FORM is specifies the name form associated with this DIT structure
   //          rule;
   //      SUP identifies superior rules (by rule id); and
   //      <extensions> describe extensions.
   //
   //    If no superior rules are identified, the DIT structure rule applies
   //    to an autonomous administrative point (e.g., the root vertex of the
   //    subtree controlled by the subschema) [X.501].
   //
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.8.  DIT Structure Rule Description
   //
   //    A value of the DIT Structure Rule Description syntax is the
   //    definition of a DIT structure rule.  The LDAP-specific encoding of a
   //    value of this syntax is defined by the <DITStructureRuleDescription>
   //    rule in [RFC4512].
   //
   //       Example:
   //          ( 2 DESC 'organization structure rule' FORM 2.5.15.3 )
   //
   //    The LDAP definition for the DIT Structure Rule Description syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.17
   //          DESC 'DIT Structure Rule Description' )
   //
   //    This syntax corresponds to the DITStructureRuleDescription ASN.1 type
   //    from [X.501].
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.17",
   .name          =  "DITStructureRuleDescription",
   .desc          =  "DIT Structure Rule Description",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF | LDAPSCHEMA_O_SCHEMA_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.17 DESC 'DIT Structure Rule Description' )",
   .abnf          =  "DITStructureRuleDescription = LPAREN WSP\n"
                     "    ruleid                     ; rule identifier\n"
                     "    [ SP \"NAME\" SP qdescrs ]   ; short names (descriptors)\n"
                     "    [ SP \"DESC\" SP qdstring ]  ; description\n"
                     "    [ SP \"OBSOLETE\" ]          ; not active\n"
                     "    SP \"FORM\" SP oid           ; NameForm\n"
                     "    [ SP \"SUP\" ruleids ]       ; superior rules\n"
                     "    extensions WSP RPAREN      ; extensions\n"
                     "\n"
                     "ruleids = ruleid / ( LPAREN WSP ruleidlist WSP RPAREN )\n"
                     "ruleidlist = ruleid *( SP ruleid )\n"
                     "ruleid = number\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.8",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4514               LDAP: Distinguished Names               June 2006
   //
   // 3.  Parsing a String Back to a Distinguished Name
   //
   //    The string representation of Distinguished Names is restricted to
   //    UTF-8 [RFC3629] encoded Unicode [Unicode] characters.  The structure
   //    of this string representation is specified using the following
   //    Augmented BNF [RFC4234] grammar:
   //
   //       distinguishedName = [ relativeDistinguishedName
   //           *( COMMA relativeDistinguishedName ) ]
   //       relativeDistinguishedName = attributeTypeAndValue
   //           *( PLUS attributeTypeAndValue )
   //       attributeTypeAndValue = attributeType EQUALS attributeValue
   //       attributeType = descr / numericoid
   //       attributeValue = string / hexstring
   //
   //       ; The following characters are to be escaped when they appear
   //       ; in the value to be encoded: ESC, one of <escaped>, leading
   //       ; SHARP or SPACE, trailing SPACE, and NULL.
   //       string =   [ ( leadchar / pair ) [ *( stringchar / pair )
   //          ( trailchar / pair ) ] ]
   //
   //       leadchar = LUTF1 / UTFMB
   //       LUTF1 = %x01-1F / %x21 / %x24-2A / %x2D-3A /
   //          %x3D / %x3F-5B / %x5D-7F
   //
   //       trailchar  = TUTF1 / UTFMB
   //       TUTF1 = %x01-1F / %x21 / %x23-2A / %x2D-3A /
   //          %x3D / %x3F-5B / %x5D-7F
   //
   //       stringchar = SUTF1 / UTFMB
   //       SUTF1 = %x01-21 / %x23-2A / %x2D-3A /
   //          %x3D / %x3F-5B / %x5D-7F
   //
   //       pair = ESC ( ESC / special / hexpair )
   //       special = escaped / SPACE / SHARP / EQUALS
   //       escaped = DQUOTE / PLUS / COMMA / SEMI / LANGLE / RANGLE
   //       hexstring = SHARP 1*hexpair
   //       hexpair = HEX HEX
   //
   //    where the productions <descr>, <numericoid>, <COMMA>, <DQUOTE>,
   //    <EQUALS>, <ESC>, <HEX>, <LANGLE>, <NULL>, <PLUS>, <RANGLE>, <SEMI>,
   //    <SPACE>, <SHARP>, and <UTFMB> are defined in [RFC4512].
   //
   //    Each <attributeType>, either a <descr> or a <numericoid>, refers to
   //    an attribute type of an attribute value assertion (AVA).  The
   //    <attributeType> is followed by an <EQUALS> and an <attributeValue>.
   //    The <attributeValue> is either in <string> or <hexstring> form.
   //
   //    If in <string> form, a LDAP string representation asserted value can
   //    be obtained by replacing (left to right, non-recursively) each <pair>
   //    appearing in the <string> as follows:
   //
   //       replace <ESC><ESC> with <ESC>;
   //       replace <ESC><special> with <special>;
   //       replace <ESC><hexpair> with the octet indicated by the <hexpair>.
   //
   //    If in <hexstring> form, a BER representation can be obtained from
   //    converting each <hexpair> of the <hexstring> to the octet indicated
   //    by the <hexpair>.
   //
   //    There is one or more attribute value assertions, separated by <PLUS>,
   //    for a relative distinguished name.
   //
   //    There is zero or more relative distinguished names, separated by
   //    <COMMA>, for a distinguished name.
   //
   //    Implementations MUST recognize AttributeType name strings
   //    (descriptors) listed in the following table, but MAY recognize other
   //    name strings.
   //
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.9.  DN
   //
   //    A value of the DN syntax is the (purported) distinguished name (DN)
   //    of an entry [RFC4512].  The LDAP-specific encoding of a value of this
   //    syntax is defined by the <distinguishedName> rule from the string
   //    representation of distinguished names [RFC4514].
   //
   //       Examples (from [RFC4514]):
   //          UID=jsmith,DC=example,DC=net
   //          OU=Sales+CN=J. Smith,DC=example,DC=net
   //          CN=John Smith\, III,DC=example,DC=net
   //          CN=Before\0dAfter,DC=example,DC=net
   //          1.3.6.1.4.1.1466.0=#04024869,DC=example,DC=com
   //          CN=Lu\C4\8Di\C4\87
   //
   //    The LDAP definition for the DN syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.12 DESC 'DN' )
   //
   //    The DN syntax corresponds to the DistinguishedName ASN.1 type from
   //    [X.501].  Note that a BER encoded distinguished name (as used by
   //    X.500) re-encoded into the LDAP-specific encoding is not necessarily
   //    reversible to the original BER encoding since the chosen string type
   //    in any DirectoryString components of the distinguished name is not
   //    indicated in the LDAP-specific encoding of the distinguished name
   //    (see Section 3.3.6).
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.12",
   .name          =  "distinguishedName",
   .desc          =  "DN",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_UTF8,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.12 DESC 'DN' )",
   .abnf          =  "distinguishedName = [ relativeDistinguishedName\n"
                     "    *( COMMA relativeDistinguishedName ) ]\n"
                     "relativeDistinguishedName = attributeTypeAndValue\n"
                     "    *( PLUS attributeTypeAndValue )\n"
                     "attributeTypeAndValue = attributeType EQUALS attributeValue\n"
                     "attributeType = descr / numericoid\n"
                     "attributeValue = string / hexstring\n"
                     "\n"
                     "; The following characters are to be escaped when they appear\n"
                     "; in the value to be encoded: ESC, one of <escaped>, leading\n"
                     "; SHARP or SPACE, trailing SPACE, and NULL.\n"
                     "string =   [ ( leadchar / pair ) [ *( stringchar / pair )\n"
                     "   ( trailchar / pair ) ] ]\n"
                     "\n"
                     "leadchar = LUTF1 / UTFMB\n"
                     "LUTF1 = %x01-1F / %x21 / %x24-2A / %x2D-3A /\n"
                     "   %x3D / %x3F-5B / %x5D-7F\n"
                     "\n"
                     "trailchar  = TUTF1 / UTFMB\n"
                     "TUTF1 = %x01-1F / %x21 / %x23-2A / %x2D-3A /\n"
                     "   %x3D / %x3F-5B / %x5D-7F\n"
                     "\n"
                     "stringchar = SUTF1 / UTFMB\n"
                     "SUTF1 = %x01-21 / %x23-2A / %x2D-3A /\n"
                     "   %x3D / %x3F-5B / %x5D-7F\n"
                     "\n"
                     "pair = ESC ( ESC / special / hexpair )\n"
                     "special = escaped / SPACE / SHARP / EQUALS\n"
                     "escaped = DQUOTE / PLUS / COMMA / SEMI / LANGLE / RANGLE\n"
                     "hexstring = SHARP 1*hexpair\n"
                     "hexpair = HEX HEX\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.9",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "UID=jsmith,DC=example,DC=net",
                        "OU=Sales+CN=J.  Smith,DC=example,DC=net",
                        "CN=James \\\"Jim\\\" Smith\\, III,DC=example,DC=net",
                        "CN=Before\\0dAfter,DC=example,DC=net",
                        NULL,
                     },
};



{
   //               
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.10.  Enhanced Guide
   //
   //    A value of the Enhanced Guide syntax suggests criteria, which consist
   //    of combinations of attribute types and filter operators, to be used
   //    in constructing filters to search for entries of particular object
   //    classes.  The Enhanced Guide syntax improves upon the Guide syntax by
   //    allowing the recommended depth of the search to be specified.
   //
   //    The LDAP-specific encoding of a value of this syntax is defined by
   //    the following ABNF:
   //
   //       EnhancedGuide = object-class SHARP WSP criteria WSP
   //                          SHARP WSP subset
   //       object-class  = WSP oid WSP
   //       subset        = "baseobject" / "oneLevel" / "wholeSubtree"
   //
   //       criteria   = and-term *( BAR and-term )
   //       and-term   = term *( AMPERSAND term )
   //       term       = EXCLAIM term /
   //                    attributetype DOLLAR match-type /
   //                    LPAREN criteria RPAREN /
   //                    true /
   //                    false
   //       match-type = "EQ" / "SUBSTR" / "GE" / "LE" / "APPROX"
   //       true       = "?true"
   //       false      = "?false"
   //       BAR        = %x7C  ; vertical bar ("|")
   //       AMPERSAND  = %x26  ; ampersand ("&")
   //       EXCLAIM    = %x21  ; exclamation mark ("!")
   //
   //    The <SHARP>, <WSP>, <oid>, <LPAREN>, <RPAREN>, <attributetype>, and
   //    <DOLLAR> rules are defined in [RFC4512].
   //
   //    The LDAP definition for the Enhanced Guide syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.21 DESC 'Enhanced Guide' )
   //
   //       Example:
   //          person#(sn$EQ)#oneLevel
   //
   //    The Enhanced Guide syntax corresponds to the EnhancedGuide ASN.1 type
   //    from [X.520].  The EnhancedGuide type references the Criteria ASN.1
   //    type, also from [X.520].  The <true> rule, above, represents an empty
   //    "and" expression in a value of the Criteria type.  The <false> rule,
   //    above, represents an empty "or" expression in a value of the Criteria
   //    type.
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.21",
   .name          =  "EnhancedGuide",
   .desc          =  "Enhanced Guide",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.21 DESC 'Enhanced Guide' )",
   .abnf          =  "EnhancedGuide = object-class SHARP WSP criteria WSP\n"
                     "                   SHARP WSP subset\n"
                     "object-class  = WSP oid WSP\n"
                     "subset        = \"baseobject\" / \"oneLevel\" / \"wholeSubtree\"\n"
                     "   \n"
                     "criteria   = and-term *( BAR and-term )\n"
                     "and-term   = term *( AMPERSAND term )\n"
                     "term       = EXCLAIM term /\n"
                     "             attributetype DOLLAR match-type /\n"
                     "             LPAREN criteria RPAREN /\n"
                     "             true /\n"
                     "             false \n"
                     "match-type = \"EQ\" / \"SUBSTR\" / \"GE\" / \"LE\" / \"APPROX\"\n"
                     "true       = \"?true\"\n"
                     "false      = \"?false\"\n"
                     "BAR        = %x7C  ; vertical bar (\"|\") \n"
                     "AMPERSAND  = %x26  ; ampersand (\"&\") \n"
                     "EXCLAIM    = %x21  ; exclamation mark (\"!\") \n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.10",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "person#(sn$EQ)#oneLevel",
                        NULL,
                     },
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.11.  Facsimile Telephone Number
   //
   //    A value of the Facsimile Telephone Number syntax is a subscriber
   //    number of a facsimile device on the public switched telephone
   //    network.  The LDAP-specific encoding of a value of this syntax is
   //    defined by the following ABNF:
   //
   //       fax-number       = telephone-number *( DOLLAR fax-parameter )
   //       telephone-number = PrintableString
   //       fax-parameter    = "twoDimensional" /
   //                          "fineResolution" /
   //                          "unlimitedLength" /
   //                          "b4Length" /
   //                          "a3Width" /
   //                          "b4Width" /
   //                          "uncompressed"
   //
   //    The <telephone-number> is a string of printable characters that
   //    complies with the internationally agreed format for representing
   //    international telephone numbers [E.123].  The <PrintableString> rule
   //    is defined in Section 3.2.  The <DOLLAR> rule is defined in
   //    [RFC4512].
   //
   //    The LDAP definition for the Facsimile Telephone Number syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.22 DESC 'Facsimile Telephone Number')
   //
   //    The Facsimile Telephone Number syntax corresponds to the
   //    FacsimileTelephoneNumber ASN.1 type from [X.520].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.22",
   .name          =  "FacsimileTelephoneNumber",
   .desc          =  "Facsimile Telephone Number",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.22 DESC 'Facsimile Telephone Number')",
   .abnf          =  "fax-number       = telephone-number *( DOLLAR fax-parameter )\n"
                     "telephone-number = PrintableString\n"
                     "fax-parameter    = \"twoDimensional\" /\n"
                     "                   \"fineResolution\" /\n"
                     "                   \"unlimitedLength\" /\n"
                     "                   \"b4Length\" /\n"
                     "                   \"a3Width\" /\n"
                     "                   \"b4Width\" /\n"
                     "                   \"uncompressed\"\n"
                     "PrintableString    = 1*PrintableCharacter\n"
                     "PrintableCharacter = ALPHA / DIGIT / SQUOTE / LPAREN / RPAREN /\n"
                     "                     PLUS / COMMA / HYPHEN / DOT / EQUALS /\n"
                     "                     SLASH / COLON / QUESTION / SPACE\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.11",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.12.  Fax
   //
   //   A value of the Fax syntax is an image that is produced using the
   //    Group 3 facsimile process [FAX] to duplicate an object, such as a
   //    memo.  The LDAP-specific encoding of a value of this syntax is the
   //    string of octets for a Group 3 Fax image as defined in [FAX].
   //
   //    The LDAP definition for the Fax syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.23 DESC 'Fax' )
   //
   //    The ASN.1 type corresponding to the Fax syntax is defined as follows,
   //    assuming EXPLICIT TAGS:
   //
   //      Fax ::= CHOICE {
   //         g3-facsimile  [3] G3FacsimileBodyPart
   //       }
   //
   //    The G3FacsimileBodyPart ASN.1 type is defined in [X.420].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.23",
   .name          =  "Fax",
   .desc          =  "Fax",
   .flags         =  0,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_IMAGE,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.23 DESC 'Fax' )",
   .abnf          =  NULL,
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.12",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.13.  Generalized Time
   //
   //    A value of the Generalized Time syntax is a character string
   //    representing a date and time.  The LDAP-specific encoding of a value
   //    of this syntax is a restriction of the format defined in [ISO8601],
   //    and is described by the following ABNF:
   //
   //       GeneralizedTime = century year month day hour
   //                            [ minute [ second / leap-second ] ]
   //                            [ fraction ]
   //                            g-time-zone
   //
   //       century = 2(%x30-39) ; "00" to "99"
   //       year    = 2(%x30-39) ; "00" to "99"
   //       month   =   ( %x30 %x31-39 ) ; "01" (January) to "09"
   //                 / ( %x31 %x30-32 ) ; "10" to "12"
   //       day     =   ( %x30 %x31-39 )    ; "01" to "09"
   //                 / ( %x31-32 %x30-39 ) ; "10" to "29"
   //                 / ( %x33 %x30-31 )    ; "30" to "31"
   //       hour    = ( %x30-31 %x30-39 ) / ( %x32 %x30-33 ) ; "00" to "23"
   //       minute  = %x30-35 %x30-39                        ; "00" to "59"
   //
   //       second      = ( %x30-35 %x30-39 ) ; "00" to "59"
   //       leap-second = ( %x36 %x30 )       ; "60"
   //
   //       fraction        = ( DOT / COMMA ) 1*(%x30-39)
   //       g-time-zone     = %x5A  ; "Z"
   //                         / g-differential
   //       g-differential  = ( MINUS / PLUS ) hour [ minute ]
   //       MINUS           = %x2D  ; minus sign ("-")
   //
   //    The <DOT>, <COMMA>, and <PLUS> rules are defined in [RFC4512].
   //
   //    The above ABNF allows character strings that do not represent valid
   //    dates (in the Gregorian calendar) and/or valid times (e.g., February
   //    31, 1994).  Such character strings SHOULD be considered invalid for
   //    this syntax.
   //
   //    The time value represents coordinated universal time (equivalent to
   //    Greenwich Mean Time) if the "Z" form of <g-time-zone> is used;
   //    otherwise, the value represents a local time in the time zone
   //    indicated by <g-differential>.  In the latter case, coordinated
   //    universal time can be calculated by subtracting the differential from
   //    the local time.  The "Z" form of <g-time-zone> SHOULD be used in
   //    preference to <g-differential>.
   //
   //    If <minute> is omitted, then <fraction> represents a fraction of an
   //    hour; otherwise, if <second> and <leap-second> are omitted, then
   //    <fraction> represents a fraction of a minute; otherwise, <fraction>
   //    represents a fraction of a second.
   //
   //       Examples:
   //          199412161032Z
   //          199412160532-0500
   //
   //    Both example values represent the same coordinated universal time:
   //    10:32 AM, December 16, 1994.
   //
   //    The LDAP definition for the Generalized Time syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.24 DESC 'Generalized Time' )
   //
   //    This syntax corresponds to the GeneralizedTime ASN.1 type from
   //    [ASN.1], with the constraint that local time without a differential
   //    SHALL NOT be used.
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.24",
   .name          =  "GeneralizedTime",
   .desc          =  "Generalized Time",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.24 DESC 'Generalized Time' )",
   .abnf          =  "GeneralizedTime = century year month day hour\n"
                     "                     [ minute [ second / leap-second ] ]\n"
                     "                     [ fraction ]\n"
                     "                     g-time-zone\n"
                     "\n"
                     "century = 2(%x30-39) ; \"00\" to \"99\"\n"
                     "year    = 2(%x30-39) ; \"00\" to \"99\"\n"
                     "month   =   ( %x30 %x31-39 ) ; \"01\" (January) to \"09\"\n"
                     "          / ( %x31 %x30-32 ) ; \"10\" to \"12\"\n"
                     "day     =   ( %x30 %x31-39 )    ; \"01\" to \"09\"\n"
                     "          / ( %x31-32 %x30-39 ) ; \"10\" to \"29\"\n"
                     "          / ( %x33 %x30-31 )    ; \"30\" to \"31\"\n"
                     "hour    = ( %x30-31 %x30-39 ) / ( %x32 %x30-33 ) ; \"00\" to \"23\"\n"
                     "minute  = %x30-35 %x30-39                        ; \"00\" to \"59\"\n"
                     "\n"
                     "second      = ( %x30-35 %x30-39 ) ; \"00\" to \"59\"\n"
                     "leap-second = ( %x36 %x30 )       ; \"60\"\n"
                     "\n"
                     "fraction        = ( DOT / COMMA ) 1*(%x30-39)\n"
                     "g-time-zone     = %x5A  ; \"Z\" \n"
                     "                  / g-differential\n"
                     "g-differential  = ( MINUS / PLUS ) hour [ minute ]\n"
                     "MINUS           = %x2D  ; minus sign (\"-\") \n"
                     "DOT     = %x2E ; period (\".\")\n"
                     "COMMA   = %x2C ; comma (\",\")\n"
                     "PLUS    = %x2B ; plus sign (\"+\")\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.13",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "199412161032Z",
                        "199412160532-0500",
                        NULL,
                     },
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.14.  Guide
   //
   //    A value of the Guide syntax suggests criteria, which consist of
   //    combinations of attribute types and filter operators, to be used in
   //    constructing filters to search for entries of particular object
   //    classes.  The Guide syntax is obsolete and should not be used for
   //    defining new attribute types.
   //
   //    The LDAP-specific encoding of a value of this syntax is defined by
   //    the following ABNF:
   //
   //       Guide = [ object-class SHARP ] criteria
   //
   //    The <object-class> and <criteria> rules are defined in Section
   //    3.3.10.  The <SHARP> rule is defined in [RFC4512].
   //
   //    The LDAP definition for the Guide syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.25 DESC 'Guide' )
   //
   //    The Guide syntax corresponds to the Guide ASN.1 type from [X.520].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.25",
   .name          =  "Guide",
   .desc          =  "Guide",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.25 DESC 'Guide' )",
   .abnf          =  "Guide = [ object-class SHARP ] criteria\n"
                     "object-class  = WSP oid WSP\n"
                     "criteria   = and-term *( BAR and-term )\n"
                     "and-term   = term *( AMPERSAND term )\n"
                     "term       = EXCLAIM term /\n"
                     "             attributetype DOLLAR match-type /\n"
                     "             LPAREN criteria RPAREN /\n"
                     "             true /\n"
                     "             false\n"
                     "match-type = \"EQ\" / \"SUBSTR\" / \"GE\" / \"LE\" / \"APPROX\"\n"
                     "true       = \"?true\"\n"
                     "false      = \"?false\"\n"
                     "BAR        = %x7C  ; vertical bar (\"|\")\n"
                     "AMPERSAND  = %x26  ; ampersand (\"&\")\n"
                     "EXCLAIM    = %x21  ; exclamation mark (\"!\")\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.14",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.15.  IA5 String
   //
   //    A value of the IA5 String syntax is a string of zero, one, or more
   //    characters from International Alphabet 5 (IA5) [T.50], the
   //    international version of the ASCII character set.  The LDAP-specific
   //    encoding of a value of this syntax is the unconverted string of
   //    characters, which conforms to the <IA5String> rule in Section 3.2.
   //
   //    The LDAP definition for the IA5 String syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.26 DESC 'IA5 String' )
   //
   //    This syntax corresponds to the IA5String ASN.1 type from [ASN.1].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.26",
   .name          =  "IA5String",
   .desc          =  "IA5 String",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.26 DESC 'IA5 String' )",
   .abnf          =  "IA5String          = *(%x00-7F)",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.15",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.16.  Integer
   //
   //    A value of the Integer syntax is a whole number of unlimited
   //    magnitude.  The LDAP-specific encoding of a value of this syntax is
   //    the optionally signed decimal digit character string representation
   //    of the number (for example, the number 1321 is represented by the
   //    character string "1321").  The encoding is defined by the following
   //    ABNF:
   //
   //       Integer = ( HYPHEN LDIGIT *DIGIT ) / number
   //
   //    The <HYPHEN>, <LDIGIT>, <DIGIT>, and <number> rules are defined in
   //    [RFC4512].
   //
   //    The LDAP definition for the Integer syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.27 DESC 'INTEGER' )
   //
   //    This syntax corresponds to the INTEGER ASN.1 type from [ASN.1].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.27",
   .name          =  "Integer",
   .desc          =  "Integer",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.27 DESC 'INTEGER' )",
   .abnf          =  "Integer = ( HYPHEN LDIGIT *DIGIT ) / number\n"
                     "number  = DIGIT / ( LDIGIT 1*DIGIT )\n"
                     "HYPHEN  = %x2D ; hyphen (\"-\")\n"
                     "DIGIT   = %x30 / LDIGIT       ; \"0\"-\"9\"\n"
                     "LDIGIT  = %x31-39             ; \"1\"-\"9\"\n",
   .re_posix      =  "^(-[1-9][0-9]{0,}|[0-9]{1,})$",
   .re_pcre       =  "^(-[1-9][0-9]{0,}|[0-9]{1,})$",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.16",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.17.  JPEG
   //
   //    A value of the JPEG syntax is an image in the JPEG File Interchange
   //    Format (JFIF), as described in [JPEG].  The LDAP-specific encoding of
   //    a value of this syntax is the sequence of octets of the JFIF encoding
   //    of the image.
   //
   //    The LDAP definition for the JPEG syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.28 DESC 'JPEG' )
   //
   //    The JPEG syntax corresponds to the following ASN.1 type:
   //
   //       JPEG ::= OCTET STRING (CONSTRAINED BY
   //                    { -- contents octets are an image in the --
   //                      -- JPEG File Interchange Format -- })
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.28",
   .name          =  "JPEG",
   .desc          =  "JPEG",
   .flags         =  0,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_IMAGE,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.28 DESC 'JPEG' )",
   .abnf          =  NULL,
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.17",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.18.  LDAP Syntax Description
   //
   //    A value of the LDAP Syntax Description syntax is the description of
   //    an LDAP syntax.  The LDAP-specific encoding of a value of this syntax
   //    is defined by the <SyntaxDescription> rule in [RFC4512].
   //
   //    The LDAP definition for the LDAP Syntax Description syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.54 DESC 'LDAP Syntax Description' )
   //
   //    The above LDAP definition for the LDAP Syntax Description syntax is
   //    itself a legal value of the LDAP Syntax Description syntax.
   //
   //    The ASN.1 type corresponding to the LDAP Syntax Description syntax is
   //    defined as follows, assuming EXPLICIT TAGS:
   //
   //       LDAPSyntaxDescription ::= SEQUENCE {
   //           identifier      OBJECT IDENTIFIER,
   //           description     DirectoryString { ub-schema } OPTIONAL }
   //
   //    The DirectoryString parameterized ASN.1 type is defined in [X.520].
   //
   //    The value of ub-schema (an integer) is implementation defined.  A
   //    non-normative definition appears in [X.520].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.54",
   .name          =  "SyntaxDescription",
   .desc          =  "LDAP Syntax Description",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.54 DESC 'LDAP Syntax Description' )",
   .abnf          =  NULL,
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.18",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.19.  Matching Rule Description
   //
   //    A value of the Matching Rule Description syntax is the definition of
   //    a matching rule.  The LDAP-specific encoding of a value of this
   //    syntax is defined by the <MatchingRuleDescription> rule in [RFC4512].
   //
   //       Example:
   //          ( 2.5.13.2 NAME 'caseIgnoreMatch'
   //             SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
   //
   //    Note: A line break has been added for readability; it is not part of
   //    the syntax.
   //
   //    The LDAP definition for the Matching Rule Description syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.30 DESC 'Matching Rule Description' )
   //
   //    This syntax corresponds to the MatchingRuleDescription ASN.1 type
   //    from [X.501].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.30",
   .name          =  "MatchingRuleDescription",
   .desc          =  "Matching Rule Description",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.30 DESC 'Matching Rule Description' )",
   .abnf          =  NULL,
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.19",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.20.  Matching Rule Use Description
   //
   //    A value of the Matching Rule Use Description syntax indicates the
   //    attribute types to which a matching rule may be applied in an
   //    extensibleMatch search filter [RFC4511].  The LDAP-specific encoding
   //    of a value of this syntax is defined by the
   //    <MatchingRuleUseDescription> rule in [RFC4512].
   //
   //       Example:
   //          ( 2.5.13.16 APPLIES ( givenName $ surname ) )
   //
   //    The LDAP definition for the Matching Rule Use Description syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.31
   //          DESC 'Matching Rule Use Description' )
   //
   //    This syntax corresponds to the MatchingRuleUseDescription ASN.1 type
   //    from [X.501].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.31",
   .name          =  "MatchingRuleUseDescription",
   .desc          =  "Matching Rule Use Description",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.31 DESC 'Matching Rule Use Description' )",
   .abnf          =  NULL,
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.20",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.21.  Name and Optional UID
   //
   //    A value of the Name and Optional UID syntax is the distinguished name
   //    [RFC4512] of an entity optionally accompanied by a unique identifier
   //    that serves to differentiate the entity from others with an identical
   //    distinguished name.
   //
   //    The LDAP-specific encoding of a value of this syntax is defined by
   //    the following ABNF:
   //
   //       NameAndOptionalUID = distinguishedName [ SHARP BitString ]
   //
   //    The <BitString> rule is defined in Section 3.3.2.  The
   //    <distinguishedName> rule is defined in [RFC4514].  The <SHARP> rule
   //    is defined in [RFC4512].
   //
   //    Note that although the '#' character may occur in the string
   //    representation of a distinguished name, no additional escaping of
   //    this character is performed when a <distinguishedName> is encoded in
   //    a <NameAndOptionalUID>.
   //
   //       Example:
   //          1.3.6.1.4.1.1466.0=#04024869,O=Test,C=GB#'0101'B
   //
   //    The LDAP definition for the Name and Optional UID syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.34 DESC 'Name And Optional UID' )
   //
   //    This syntax corresponds to the NameAndOptionalUID ASN.1 type from
   //    [X.520].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.34",
   .name          =  "NameAndOptionalUID",
   .desc          =  "Name and Optional UID",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.34 DESC 'Name And Optional UID' )",
   .abnf          =  "NameAndOptionalUID = distinguishedName [ SHARP BitString ]",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.21",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4512                      LDAP Models                      June 2006
   //
   // 4.1.7.2.  Name Forms
   //
   //    A name form "specifies a permissible RDN for entries of a particular
   //    structural object class.  A name form identifies a named object class
   //    and one or more attribute types to be used for naming (i.e., for the
   //    RDN).  Name forms are primitive pieces of specification used in the
   //    definition of DIT structure rules" [X.501].
   //
   //    Each name form indicates the structural object class to be named, a
   //    set of required attribute types, and a set of allowed attribute
   //    types.  A particular attribute type cannot be in both sets.
   //
   //    Entries governed by the form must be named using a value from each
   //    required attribute type and zero or more values from the allowed
   //    attribute types.
   //
   //    Each name form is identified by an object identifier (OID) and,
   //    optionally, one or more short names (descriptors).
   //
   //    Name form descriptions are written according to the ABNF:
   //
   //      NameFormDescription = LPAREN WSP
   //          numericoid                 ; object identifier
   //          [ SP "NAME" SP qdescrs ]   ; short names (descriptors)
   //          [ SP "DESC" SP qdstring ]  ; description
   //          [ SP "OBSOLETE" ]          ; not active
   //          SP "OC" SP oid             ; structural object class
   //          SP "MUST" SP oids          ; attribute types
   //          [ SP "MAY" SP oids ]       ; attribute types
   //          extensions WSP RPAREN      ; extensions
   //
   //    where:
   //      <numericoid> is object identifier that identifies this name form;
   //      NAME <qdescrs> are short names (descriptors) identifying this name
   //          form;
   //      DESC <qdstring> is a short descriptive string;
   //      OBSOLETE indicates this name form is not active;
   //      OC identifies the structural object class this rule applies to,
   //      MUST and MAY specify the sets of required and allowed,
   //          respectively, naming attributes for this name form; and
   //      <extensions> describe extensions.
   //
   //    All attribute types in the required ("MUST") and allowed ("MAY")
   //    lists shall be different.
   //
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.22.  Name Form Description
   //
   //    A value of the Name Form Description syntax is the definition of a
   //    name form, which regulates how entries may be named.  The LDAP-
   //    specific encoding of a value of this syntax is defined by the
   //    <NameFormDescription> rule in [RFC4512].
   //
   //       Example:
   //          ( 2.5.15.3 NAME 'orgNameForm' OC organization MUST o )
   //
   //    The LDAP definition for the Name Form Description syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.35 DESC 'Name Form Description' )
   //
   //    This syntax corresponds to the NameFormDescription ASN.1 type from
   //    [X.501].
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.35",
   .name          =  "NameFormDescription",
   .desc          =  "Name Form Description",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.35 DESC 'Name Form Description' )",
   .abnf          =  "NameFormDescription = LPAREN WSP\n"
                     "    numericoid                 ; object identifier\n"
                     "    [ SP \"NAME\" SP qdescrs ]   ; short names (descriptors)\n"
                     "    [ SP \"DESC\" SP qdstring ]  ; description\n"
                     "    [ SP \"OBSOLETE\" ]          ; not active\n"
                     "    SP \"OC\" SP oid             ; structural object class \n"
                     "    SP \"MUST\" SP oids          ; attribute types \n"
                     "    [ SP \"MAY\" SP oids ]       ; attribute types \n"
                     "    extensions WSP RPAREN      ; extensions\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.22",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "( 2.5.15.3 NAME 'orgNameForm' OC organization MUST o )",
                        NULL,
                     },
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.23.  Numeric String
   //
   //    A value of the Numeric String syntax is a sequence of one or more
   //    numerals and spaces.  The LDAP-specific encoding of a value of this
   //    syntax is the unconverted string of characters, which conforms to the
   //    following ABNF:
   //
   //       NumericString = 1*(DIGIT / SPACE)
   //
   //    The <DIGIT> and <SPACE> rules are defined in [RFC4512].
   //
   //       Example:
   //          15 079 672 281
   //
   //    The LDAP definition for the Numeric String syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.36 DESC 'Numeric String' )
   //
   //    This syntax corresponds to the NumericString ASN.1 type from [ASN.1].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.36",
   .name          =  "NumericString",
   .desc          =  "Numeric String",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.36 DESC 'Numeric String' )",
   .abnf          =  "NumericString = 1*(DIGIT / SPACE)\n"
                     "DIGIT   = %x30 / LDIGIT       ; \"0\"-\"9\"\n"
                     "LDIGIT  = %x31-39             ; \"1\"-\"9\"\n"
                     "SPACE   = %x20 ; space (\" \")\n",
   .re_posix      =  "^([ 0-9]+)$",
   .re_pcre       =  "^([ 0-9]+)$",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.23",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "15 079 672 281",
                        NULL,
                     },
};



{
   //
   // RFC 4512                      LDAP Models                      June 2006
   //
   // 4.1.1.  Object Class Definitions
   //
   //    Object Class definitions are written according to the ABNF:
   //
   //      ObjectClassDescription = LPAREN WSP
   //          numericoid                 ; object identifier
   //          [ SP "NAME" SP qdescrs ]   ; short names (descriptors)
   //          [ SP "DESC" SP qdstring ]  ; description
   //          [ SP "OBSOLETE" ]          ; not active
   //          [ SP "SUP" SP oids ]       ; superior object classes
   //          [ SP kind ]                ; kind of class
   //          [ SP "MUST" SP oids ]      ; attribute types
   //          [ SP "MAY" SP oids ]       ; attribute types
   //          extensions WSP RPAREN
   //
   //      kind = "ABSTRACT" / "STRUCTURAL" / "AUXILIARY"
   //
   //    where:
   //      <numericoid> is object identifier assigned to this object class;
   //      NAME <qdescrs> are short names (descriptors) identifying this
   //          object class;
   //      DESC <qdstring> is a short descriptive string;
   //      OBSOLETE indicates this object class is not active;
   //      SUP <oids> specifies the direct superclasses of this object class;
   //      the kind of object class is indicated by one of ABSTRACT,
   //          STRUCTURAL, or AUXILIARY (the default is STRUCTURAL);
   //      MUST and MAY specify the sets of required and allowed attribute
   //          types, respectively; and
   //      <extensions> describe extensions.
   //
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.24.  Object Class Description
   //
   //    A value of the Object Class Description syntax is the definition of
   //    an object class.  The LDAP-specific encoding of a value of this
   //    syntax is defined by the <ObjectClassDescription> rule in [RFC4512].
   //
   //       Example:
   //          ( 2.5.6.2 NAME 'country' SUP top STRUCTURAL MUST c
   //             MAY ( searchGuide $ description ) )
   //
   //    Note: A line break has been added for readability; it is not part of
   //    the syntax.
   //
   //    The LDAP definition for the Object Class Description syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.37 DESC 'Object Class Description' )
   //
   //    This syntax corresponds to the ObjectClassDescription ASN.1 type from
   //    [X.501].
   //
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.37",
   .name          =  "ObjectClassDescription",
   .desc          =  "Object Class Description",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF | LDAPSCHEMA_O_SCHEMA_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.37 DESC 'Object Class Description' )",
   .abnf          =  "ObjectClassDescription = LPAREN WSP\n"
                     "    numericoid                 ; object identifier\n"
                     "    [ SP \"NAME\" SP qdescrs ]   ; short names (descriptors)\n"
                     "    [ SP \"DESC\" SP qdstring ]  ; description\n"
                     "    [ SP \"OBSOLETE\" ]          ; not active\n"
                     "    [ SP \"SUP\" SP oids ]       ; superior object classes\n"
                     "    [ SP kind ]                ; kind of class \n"
                     "    [ SP \"MUST\" SP oids ]      ; attribute types \n"
                     "    [ SP \"MAY\" SP oids ]       ; attribute types \n"
                     "    extensions WSP RPAREN\n"
                     "\n"
                     "kind = \"ABSTRACT\" / \"STRUCTURAL\" / \"AUXILIARY\"\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.24",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "( 2.5.6.2 NAME 'country' SUP top STRUCTURAL MUST c MAY ( searchGuide $ description ) )",
                        NULL,
                     },
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.25.  Octet String
   //
   //    A value of the Octet String syntax is a sequence of zero, one, or
   //    more arbitrary octets.  The LDAP-specific encoding of a value of this
   //    syntax is the unconverted sequence of octets, which conforms to the
   //    following ABNF:
   //
   //       OctetString = *OCTET
   //
   //    The <OCTET> rule is defined in [RFC4512].  Values of this syntax are
   //    not generally human-readable.
   //
   //    The LDAP definition for the Octet String syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.40 DESC 'Octet String' )
   //
   //    This syntax corresponds to the OCTET STRING ASN.1 type from [ASN.1].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.40",
   .name          =  "OctetString",
   .desc          =  "Octet String",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.40 DESC 'Octet String' )",
   .abnf          =  "OctetString = *OCTET\n"
                     "OCTET   = %x00-FF ; Any octet (8-bit data unit)\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.25",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.26.  OID
   //
   //    A value of the OID syntax is an object identifier: a sequence of two
   //    or more non-negative integers that uniquely identify some object or
   //    item of specification.  Many of the object identifiers used in LDAP
   //    also have IANA registered names [RFC4520].
   //
   //    The LDAP-specific encoding of a value of this syntax is defined by
   //    the <oid> rule in [RFC4512].
   //
   //       Examples:
   //          1.2.3.4
   //          cn
   //
   //    The LDAP definition for the OID syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.38 DESC 'OID' )
   //
   //    This syntax corresponds to the OBJECT IDENTIFIER ASN.1 type from
   //    [ASN.1].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.38",
   .name          =  "OID",
   .desc          =  "OID",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.38 DESC 'OID' )",
   .abnf          =  "oid = descr / numericoid\n"
                     "\n"
                     "descr = keystring\n"
                     "keystring = leadkeychar *keychar\n"
                     "leadkeychar = ALPHA\n"
                     "keychar = ALPHA / DIGIT / HYPHEN\n"
                     "\n"
                     "numericoid = number 1*( DOT number )\n"
                     "number  = DIGIT / ( LDIGIT 1*DIGIT )\n"
                     "\n"
                     "ALPHA   = %x41-5A / %x61-7A   ; \"A\"-\"Z\" / \"a\"-\"z\"\n"
                     "DIGIT   = %x30 / LDIGIT       ; \"0\"-\"9\"\n"
                     "LDIGIT  = %x31-39             ; \"1\"-\"9\"\n"
                     "DOT     = %x2E ; period (\".\")\n"
                     "HYPHEN  = %x2D ; hyphen (\"-\")\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.26",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "1.2.3.4",
                        "cn",
                        NULL,
                     },
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.27.  Other Mailbox
   //
   //    A value of the Other Mailbox syntax identifies an electronic mailbox,
   //    in a particular named mail system.  The LDAP-specific encoding of a
   //    value of this syntax is defined by the following ABNF:
   //
   //       OtherMailbox = mailbox-type DOLLAR mailbox
   //       mailbox-type = PrintableString
   //       mailbox      = IA5String
   //
   //    The <mailbox-type> rule represents the type of mail system in which
   //    the mailbox resides (for example, "MCIMail"), and <mailbox> is the
   //    actual mailbox in the mail system described by <mailbox-type>.  The
   //    <PrintableString> and <IA5String> rules are defined in Section 3.2.
   //    The <DOLLAR> rule is defined in [RFC4512].
   //
   //    The LDAP definition for the Other Mailbox syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.39 DESC 'Other Mailbox' )
   //
   //    The ASN.1 type corresponding to the Other Mailbox syntax is defined
   //    as follows, assuming EXPLICIT TAGS:
   //
   //       OtherMailbox ::= SEQUENCE {
   //           mailboxType  PrintableString,
   //           mailbox      IA5String
   //       }
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.39",
   .name          =  "OtherMailbox",
   .desc          =  "Other Mailbox",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.39 DESC 'Other Mailbox' )",
   .abnf          =  "OtherMailbox = mailbox-type DOLLAR mailbox\n"
                     "mailbox-type = PrintableString\n"
                     "mailbox      = IA5String\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.27",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.28.  Postal Address
   //
   //    A value of the Postal Address syntax is a sequence of strings of one
   //    or more arbitrary UCS characters, which form an address in a physical
   //    mail system.
   //
   //    The LDAP-specific encoding of a value of this syntax is defined by
   //    the following ABNF:
   //
   //       PostalAddress = line *( DOLLAR line )
   //       line          = 1*line-char
   //       line-char     = %x00-23
   //                       / (%x5C "24")  ; escaped "$"
   //                       / %x25-5B
   //                       / (%x5C "5C")  ; escaped "\"
   //                       / %x5D-7F
   //                       / UTFMB
   //
   //    Each character string (i.e., <line>) of a postal address value is
   //    encoded as a UTF-8 [RFC3629] string, except that "\" and "$"
   //    characters, if they occur in the string, are escaped by a "\"
   //    character followed by the two hexadecimal digit code for the
   //    character.  The <DOLLAR> and <UTFMB> rules are defined in [RFC4512].
   //
   //    Many servers limit the postal address to no more than six lines of no
   //    more than thirty characters each.
   //
   //       Example:
   //          1234 Main St.$Anytown, CA 12345$USA
   //          \241,000,000 Sweepstakes$PO Box 1000000$Anytown, CA 12345$USA
   //
   //    The LDAP definition for the Postal Address syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.41 DESC 'Postal Address' )
   //
   //    This syntax corresponds to the PostalAddress ASN.1 type from [X.520];
   //    that is
   //
   //       PostalAddress ::= SEQUENCE SIZE(1..ub-postal-line) OF
   //           DirectoryString { ub-postal-string }
   //
   //    The values of ub-postal-line and ub-postal-string (both integers) are
   //    implementation defined.  Non-normative definitions appear in [X.520].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.41",
   .name          =  "PostalAddress",
   .desc          =  "Postal Address",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_UTF8,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.41 DESC 'Postal Address' )",
   .abnf          =  "PostalAddress = line *( DOLLAR line )\n"
                     "line          = 1*line-char\n"
                     "line-char     = %x00-23\n"
                     "                / (%x5C \"24\")  ; escaped \"$\"\n"
                     "                / %x25-5B\n"
                     "                / (%x5C \"5C\")  ; escaped \"\\"\n"
                     "                / %x5D-7F\n"
                     "                / UTFMB\n"
                     "\n"
                     "UTFMB   = UTF2 / UTF3 / UTF4\n"
                     "UTF0    = %x80-BF\n"
                     "UTF1    = %x00-7F\n"
                     "UTF2    = %xC2-DF UTF0\n"
                     "UTF3    = %xE0 %xA0-BF UTF0 / %xE1-EC 2(UTF0) /\n"
                     "          %xED %x80-9F UTF0 / %xEE-EF 2(UTF0)\n"
                     "UTF4    = %xF0 %x90-BF 2(UTF0) / %xF1-F3 3(UTF0) /\n"
                     "          %xF4 %x80-8F 2(UTF0)\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.28",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "1234 Main St.$Anytown, CA 12345$USA",
                        "\\241,000,000 Sweepstakes$PO Box 1000000$Anytown, CA 12345$USA",
                        NULL,
                     },
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.29.  Printable String
   //
   //    A value of the Printable String syntax is a string of one or more
   //    latin alphabetic, numeric, and selected punctuation characters as
   //    specified by the <PrintableCharacter> rule in Section 3.2.
   //
   //    The LDAP-specific encoding of a value of this syntax is the
   //    unconverted string of characters, which conforms to the
   //    <PrintableString> rule in Section 3.2.
   //
   //       Example:
   //          This is a PrintableString.
   //
   //    The LDAP definition for the PrintableString syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.44 DESC 'Printable String' )
   //
   //    This syntax corresponds to the PrintableString ASN.1 type from
   //    [ASN.1].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.44",
   .name          =  "PrintableString",
   .desc          =  "Printable String",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.44 DESC 'Printable String' )",
   .abnf          =  "PrintableCharacter = ALPHA / DIGIT / SQUOTE / LPAREN / RPAREN /\n"
                     "                     PLUS / COMMA / HYPHEN / DOT / EQUALS /\n"
                     "                     SLASH / COLON / QUESTION / SPACE\n"
                     "PrintableString    = 1*PrintableCharacter\n"
                     "IA5String          = *(%x00-7F)\n"
                     "SLASH              = %x2F  ; forward slash (\"/\")\n"
                     "COLON              = %x3A  ; colon (\":\")\n"
                     "QUESTION           = %x3F  ; question mark (\"?\")\n"
                     "ALPHA              = %x41-5A / %x61-7A   ; \"A\"-\"Z\" / \"a\"-\"z\"\n"
                     "DIGIT              = %x30 / LDIGIT       ; \"0\"-\"9\"\n"
                     "LDIGIT             = %x31-39             ; \"1\"-\"9\"\n"
                     "SQUOTE             = %x27 ; single quote (\"'\")\n"
                     "LPAREN             = %x28 ; left paren (\"(\")\n"
                     "RPAREN             = %x29 ; right paren (\")\")\n"
                     "PLUS               = %x2B ; plus sign (\"+\")\n"
                     "COMMA              = %x2C ; comma (\",\")\n"
                     "HYPHEN             = %x2D ; hyphen (\"-\")\n"
                     "DOT                = %x2E ; period (\".\")\n"
                     "EQUALS             = %x3D ; equals sign (\"=\")\n"
                     "SPACE              = %x20 ; space (\" \")\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.29",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "This is a PrintableString.",
                        NULL,
                     },
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //                
   // 3.3.30.  Substring Assertion
   //
   //    A value of the Substring Assertion syntax is a sequence of zero, one,
   //    or more character substrings used as an argument for substring
   //    extensible matching of character string attribute values; i.e., as
   //    the matchValue of a MatchingRuleAssertion [RFC4511].  Each substring
   //    is a string of one or more arbitrary characters from the Universal
   //    Character Set (UCS) [UCS].  A zero-length substring is not permitted.
   //
   //    The LDAP-specific encoding of a value of this syntax is defined by
   //    the following ABNF:
   //
   //       SubstringAssertion = [ initial ] any [ final ]
   //
   //       initial  = substring
   //       any      = ASTERISK *(substring ASTERISK)
   //       final    = substring
   //       ASTERISK = %x2A  ; asterisk ("*")
   //
   //       substring           = 1*substring-character
   //       substring-character = %x00-29
   //                             / (%x5C "2A")  ; escaped "*"
   //                             / %x2B-5B
   //                             / (%x5C "5C")  ; escaped "\"
   //                             / %x5D-7F
   //                             / UTFMB
   //
   //    Each <substring> of a Substring Assertion value is encoded as a UTF-8
   //    [RFC3629] string, except that "\" and "*" characters, if they occur
   //    in the substring, are escaped by a "\" character followed by the two
   //    hexadecimal digit code for the character.
   //
   //    The Substring Assertion syntax is used only as the syntax of
   //    assertion values in the extensible match.  It is not used as an
   //    attribute syntax, or in the SubstringFilter [RFC4511].
   //
   //    The LDAP definition for the Substring Assertion syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.58 DESC 'Substring Assertion' )
   //
   //    This syntax corresponds to the SubstringAssertion ASN.1 type from
   //    [X.520].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.58",
   .name          =  "SubstringAssertion",
   .desc          =  "Substring Assertion",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_UTF8,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.58 DESC 'Substring Assertion' )",
   .abnf          =  "SubstringAssertion = [ initial ] any [ final ]\n"
                     "\n"
                     "initial  = substring\n"
                     "any      = ASTERISK *(substring ASTERISK)\n"
                     "final    = substring\n"
                     "ASTERISK = %x2A  ; asterisk (\"*\")\n"
                     "\n"
                     "substring           = 1*substring-character\n"
                     "substring-character = %x00-29\n"
                     "                      / (%x5C \"2A\")  ; escaped \"*\"\n"
                     "                      / %x2B-5B\n"
                     "                      / (%x5C \"5C\")  ; escaped \"\\\"\n"
                     "                      / %x5D-7F\n"
                     "                      / UTFMB\n"
                     "\n"
                     "UTFMB   = UTF2 / UTF3 / UTF4\n"
                     "UTF0    = %x80-BF\n"
                     "UTF1    = %x00-7F\n"
                     "UTF2    = %xC2-DF UTF0\n"
                     "UTF3    = %xE0 %xA0-BF UTF0 / %xE1-EC 2(UTF0) /\n"
                     "          %xED %x80-9F UTF0 / %xEE-EF 2(UTF0)\n"
                     "UTF4    = %xF0 %x90-BF 2(UTF0) / %xF1-F3 3(UTF0) /\n"
                     "          %xF4 %x80-8F 2(UTF0)\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.30",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.31.  Telephone Number
   //
   //    A value of the Telephone Number syntax is a string of printable
   //    characters that complies with the internationally agreed format for
   //    representing international telephone numbers [E.123].
   //
   //    The LDAP-specific encoding of a value of this syntax is the
   //    unconverted string of characters, which conforms to the
   //    <PrintableString> rule in Section 3.2.
   //
   //       Examples:
   //          +1 512 315 0280
   //          +1-512-315-0280
   //          +61 3 9896 7830
   //
   //    The LDAP definition for the Telephone Number syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.50 DESC 'Telephone Number' )
   //
   //    The Telephone Number syntax corresponds to the following ASN.1 type
   //    from [X.520]:
   //
   //       PrintableString (SIZE(1..ub-telephone-number))
   //
   //    The value of ub-telephone-number (an integer) is implementation
   //    defined.  A non-normative definition appears in [X.520].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.50",
   .name          =  "TelephoneNumber",
   .desc          =  "Telephone Number",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_UTF8,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.50 DESC 'Telephone Number' )",
   .abnf          =  NULL,
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.31",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  (const char *[])
                     {
                        "+1 512 315 0280",
                        "+1-512-315-0280",
                        "+61 3 9896 7830",
                        NULL,
                     },
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.32.  Teletex Terminal Identifier
   //
   //    A value of this syntax specifies the identifier and (optionally)
   //    parameters of a teletex terminal.
   //
   //    The LDAP-specific encoding of a value of this syntax is defined by
   //    the following ABNF:
   //
   //       teletex-id = ttx-term *(DOLLAR ttx-param)
   //       ttx-term   = PrintableString          ; terminal identifier
   //       ttx-param  = ttx-key COLON ttx-value  ; parameter
   //       ttx-key    = "graphic" / "control" / "misc" / "page" / "private"
   //       ttx-value  = *ttx-value-octet
   //
   //       ttx-value-octet = %x00-23
   //                         / (%x5C "24")  ; escaped "$"
   //                         / %x25-5B
   //                         / (%x5C "5C")  ; escaped "\"
   //                         / %x5D-FF
   //
   //    The <PrintableString> and <COLON> rules are defined in Section 3.2.
   //    The <DOLLAR> rule is defined in [RFC4512].
   //
   //    The LDAP definition for the Teletex Terminal Identifier syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.51
   //          DESC 'Teletex Terminal Identifier' )
   //
   //    This syntax corresponds to the TeletexTerminalIdentifier ASN.1 type
   //    from [X.520].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.51",
   .name          =  "teletex-id",
   .desc          =  "Teletex Terminal Identifier",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.51 DESC 'Teletex Terminal Identifier' )",
   .abnf          =  "teletex-id = ttx-term *(DOLLAR ttx-param)\n"
                     "ttx-term   = PrintableString          ; terminal identifier\n"
                     "ttx-param  = ttx-key COLON ttx-value  ; parameter\n"
                     "ttx-key    = \"graphic\" / \"control\" / \"misc\" / \"page\" / \"private\"\n"
                     "ttx-value  = *ttx-value-octet\n"
                     "   \n"
                     "ttx-value-octet = %x00-23\n"
                     "                  / (%x5C \"24\")  ; escaped \"$\"\n"
                     "                  / %x25-5B\n"
                     "                  / (%x5C \"5C\")  ; escaped \"\\"\n"
                     "                  / %x5D-FF\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.32",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.33.  Telex Number
   //
   //    A value of the Telex Number syntax specifies the telex number,
   //    country code, and answerback code of a telex terminal.
   //
   //    The LDAP-specific encoding of a value of this syntax is defined by
   //    the following ABNF:
   //
   //       telex-number  = actual-number DOLLAR country-code
   //                          DOLLAR answerback
   //       actual-number = PrintableString
   //       country-code  = PrintableString
   //       answerback    = PrintableString
   //
   //    The <PrintableString> rule is defined in Section 3.2.  The <DOLLAR>
   //    rule is defined in [RFC4512].
   //
   //    The LDAP definition for the Telex Number syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.52 DESC 'Telex Number' )
   //
   //    This syntax corresponds to the TelexNumber ASN.1 type from [X.520].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.52",
   .name          =  "telex-number",
   .desc          =  "Telex Number",
   .flags         =  LDAPSCHEMA_O_READABLE | LDAPSCHEMA_O_COMMON_ABNF,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_UTF8,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.52 DESC 'Telex Number' )",
   .abnf          =  "telex-number  = actual-number DOLLAR country-code\n"
                     "                   DOLLAR answerback\n"
                     "actual-number = PrintableString\n"
                     "country-code  = PrintableString\n"
                     "answerback    = PrintableString\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.33",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 3.3.34.  UTC Time
   //
   //    A value of the UTC Time syntax is a character string representing a
   //    date and time to a precision of one minute or one second.  The year
   //    is given as a two-digit number.  The LDAP-specific encoding of a
   //    value of this syntax follows the format defined in [ASN.1] for the
   //    UTCTime type and is described by the following ABNF:
   //
   //       UTCTime         = year month day hour minute [ second ]
   //                            [ u-time-zone ]
   //       u-time-zone     = %x5A  ; "Z"
   //                         / u-differential
   //       u-differential  = ( MINUS / PLUS ) hour minute
   //
   //    The <year>, <month>, <day>, <hour>, <minute>, <second>, and <MINUS>
   //    rules are defined in Section 3.3.13.  The <PLUS> rule is defined in
   //    [RFC4512].
   //
   //    The above ABNF allows character strings that do not represent valid
   //    dates (in the Gregorian calendar) and/or valid times.  Such character
   //    strings SHOULD be considered invalid for this syntax.
   //
   //    The time value represents coordinated universal time if the "Z" form
   //    of <u-time-zone> is used; otherwise, the value represents a local
   //    time.  In the latter case, if <u-differential> is provided, then
   //    coordinated universal time can be calculated by subtracting the
   //    differential from the local time.  The <u-time-zone> SHOULD be
   //    present in time values, and the "Z" form of <u-time-zone> SHOULD be
   //    used in preference to <u-differential>.
   //
   //    The LDAP definition for the UTC Time syntax is:
   //
   //       ( 1.3.6.1.4.1.1466.115.121.1.53 DESC 'UTC Time' )
   //
   //    Note: This syntax is deprecated in favor of the Generalized Time
   //    syntax.
   //
   //    The UTC Time syntax corresponds to the UTCTime ASN.1 type from
   //    [ASN.1].
   //
   .oid           =  "1.3.6.1.4.1.1466.115.121.1.53",
   .name          =  "UTCTime",
   .desc          =  "UTC Time",
   .flags         =  LDAPSCHEMA_O_READABLE,
   .type          =  LDAPSCHEMA_SYNTAX,
   .class         =  LDAPSCHEMA_CLASS_ASCII,
   .def           =  "( 1.3.6.1.4.1.1466.115.121.1.53 DESC 'UTC Time' )",
   .abnf          =  "UTCTime         = year month day hour minute [ second ]\n"
                     "                     [ u-time-zone ]\n"
                     "u-time-zone     = %x5A  ; \"Z\" \n"
                     "                  / u-differential\n"
                     "u-differential  = ( MINUS / PLUS ) hour minute\n"
                     "\n"
                     "year            = 2(%x30-39) ; \"00\" to \"99\"\n"
                     "month           =   ( %x30 %x31-39 ) ; \"01\" (January) to \"09\"\n"
                     "                  / ( %x31 %x30-32 ) ; \"10\" to \"12\"\n"
                     "day             =   ( %x30 %x31-39 )    ; \"01\" to \"09\"\n"
                     "                  / ( %x31-32 %x30-39 ) ; \"10\" to \"29\"\n"
                     "                  / ( %x33 %x30-31 )    ; \"30\" to \"31\"\n"
                     "hour            = ( %x30-31 %x30-39 ) / ( %x32 %x30-33 ) ; \"00\" to \"23\"\n"
                     "minute          = %x30-35 %x30-39                        ; \"00\" to \"59\"\n"
                     "\n"
                     "second          = ( %x30-35 %x30-39 ) ; \"00\" to \"59\"\n"
                     "\n"
                     "MINUS           = %x2D  ; minus sign (\"-\")\n"
                     "PLUS            = %x2B ; plus sign (\"+\")\n",
   .re_posix      =  NULL,
   .re_pcre       =  NULL,
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "3.3.34",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
   .examples      =  NULL,
};



{
   //                
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.1.  bitStringMatch
   //
   //    The bitStringMatch rule compares an assertion value of the Bit String
   //    syntax to an attribute value of a syntax (e.g., the Bit String
   //    syntax) whose corresponding ASN.1 type is BIT STRING.
   //    If the corresponding ASN.1 type of the attribute syntax does not have
   //    a named bit list [ASN.1] (which is the case for the Bit String
   //    syntax), then the rule evaluates to TRUE if and only if the attribute
   //    value has the same number of bits as the assertion value and the bits
   //    match on a bitwise basis.
   //
   //    If the corresponding ASN.1 type does have a named bit list, then
   //    bitStringMatch operates as above, except that trailing zero bits in
   //    the attribute and assertion values are treated as absent.
   //
   //    The LDAP definition for the bitStringMatch rule is:
   //
   //       ( 2.5.13.16 NAME 'bitStringMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.6 )
   //
   //    The bitStringMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.16",
   .name          =  "bitStringMatch",
   .desc          =  "bitStringMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.16 NAME 'bitStringMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.6 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.1",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.2.  booleanMatch
   //
   //    The booleanMatch rule compares an assertion value of the Boolean
   //    syntax to an attribute value of a syntax (e.g., the Boolean syntax)
   //    whose corresponding ASN.1 type is BOOLEAN.
   //
   //    The rule evaluates to TRUE if and only if the attribute value and the
   //    assertion value are both TRUE or both FALSE.
   //
   //    The LDAP definition for the booleanMatch rule is:
   //
   //       ( 2.5.13.13 NAME 'booleanMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.7 )
   //
   //    The booleanMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.13",
   .name          =  "booleanMatch",                                           
   .desc          =  "booleanMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,                                     
   .def           =  "( 2.5.13.13 NAME 'booleanMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.7 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",         
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,                                   
   .spec_name     =  "4517",                                                
   .spec_section  =  "4.2.2",
   .spec_source   =  NULL,                                                  
   .spec_vendor   =  "IETF",                                                
}; 



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.3.  caseExactIA5Match
   //
   //    The caseExactIA5Match rule compares an assertion value of the IA5
   //    String syntax to an attribute value of a syntax (e.g., the IA5 String
   //    syntax) whose corresponding ASN.1 type is IA5String.
   //
   //    The rule evaluates to TRUE if and only if the prepared attribute
   //    value character string and the prepared assertion value character
   //    string have the same number of characters and corresponding
   //    characters have the same code point.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are not case folded in the Map preparation step, and only
   //    Insignificant Space Handling is applied in the Insignificant
   //    Character Handling step.
   //
   //    The LDAP definition for the caseExactIA5Match rule is:
   //
   //       ( 1.3.6.1.4.1.1466.109.114.1 NAME 'caseExactIA5Match'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
   //
   //    The caseExactIA5Match rule is an equality matching rule.
   //
   .oid           =  "1.3.6.1.4.1.1466.109.114.1",
   .name          =  "caseExactIA5Match",  
   .desc          =  "caseExactIA5Match",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 1.3.6.1.4.1.1466.109.114.1 NAME 'caseExactIA5Match' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.3",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.4.  caseExactMatch
   //
   //    The caseExactMatch rule compares an assertion value of the Directory
   //    String syntax to an attribute value of a syntax (e.g., the Directory
   //    String, Printable String, Country String, or Telephone Number syntax)
   //    whose corresponding ASN.1 type is DirectoryString or one of the
   //    alternative string types of DirectoryString, such as PrintableString
   //    (the other alternatives do not correspond to any syntax defined in
   //    this document).
   //
   //    The rule evaluates to TRUE if and only if the prepared attribute
   //    value character string and the prepared assertion value character
   //    string have the same number of characters and corresponding
   //    characters have the same code point.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are not case folded in the Map preparation step, and only
   //    Insignificant Space Handling is applied in the Insignificant
   //    Character Handling step.
   //
   //    The LDAP definition for the caseExactMatch rule is:
   //
   //       ( 2.5.13.5 NAME 'caseExactMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
   //
   //    The caseExactMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.5",
   .name          =  "caseExactMatch",
   .desc          =  "caseExactMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.5 NAME 'caseExactMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.4",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.5.  caseExactOrderingMatch
   //
   //    The caseExactOrderingMatch rule compares an assertion value of the
   //    Directory String syntax to an attribute value of a syntax (e.g., the
   //    Directory String, Printable String, Country String, or Telephone
   //    Number syntax) whose corresponding ASN.1 type is DirectoryString or
   //    one of its alternative string types.
   //
   //    The rule evaluates to TRUE if and only if, in the code point
   //    collation order, the prepared attribute value character string
   //    appears earlier than the prepared assertion value character string;
   //    i.e., the attribute value is "less than" the assertion value.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are not case folded in the Map preparation step, and only
   //    Insignificant Space Handling is applied in the Insignificant
   //    Character Handling step.
   //
   //    The LDAP definition for the caseExactOrderingMatch rule is:
   //
   //       ( 2.5.13.6 NAME 'caseExactOrderingMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
   //
   //    The caseExactOrderingMatch rule is an ordering matching rule.
   //
   .oid           =  "2.5.13.6",
   .name          =  "caseExactOrderingMatch",
   .desc          =  "caseExactOrderingMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.6 NAME 'caseExactOrderingMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.5",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.6.  caseExactSubstringsMatch
   //
   //    The caseExactSubstringsMatch rule compares an assertion value of the
   //    Substring Assertion syntax to an attribute value of a syntax (e.g.,
   //    the Directory String, Printable String, Country String, or Telephone
   //    Number syntax) whose corresponding ASN.1 type is DirectoryString or
   //    one of its alternative string types.
   //
   //    The rule evaluates to TRUE if and only if (1) the prepared substrings
   //    of the assertion value match disjoint portions of the prepared
   //    attribute value character string in the order of the substrings in
   //    the assertion value, (2) an <initial> substring, if present, matches
   //    the beginning of the prepared attribute value character string, and
   //    (3) a <final> substring, if present, matches the end of the prepared
   //    attribute value character string.  A prepared substring matches a
   //    portion of the prepared attribute value character string if
   //    corresponding characters have the same code point.
   //
   //    In preparing the attribute value and assertion value substrings for
   //    comparison, characters are not case folded in the Map preparation
   //    step, and only Insignificant Space Handling is applied in the
   //    Insignificant Character Handling step.
   //
   //    The LDAP definition for the caseExactSubstringsMatch rule is:
   //
   //       ( 2.5.13.7 NAME 'caseExactSubstringsMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )
   //
   //    The caseExactSubstringsMatch rule is a substrings matching rule.
   //
   .oid           =  "2.5.13.7",
   .name          =  "caseExactSubstringsMatch",
   .desc          =  "caseExactSubstringsMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.7 NAME 'caseExactSubstringsMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.6",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.7.  caseIgnoreIA5Match
   //
   //    The caseIgnoreIA5Match rule compares an assertion value of the IA5
   //    String syntax to an attribute value of a syntax (e.g., the IA5 String
   //    syntax) whose corresponding ASN.1 type is IA5String.
   //
   //    The rule evaluates to TRUE if and only if the prepared attribute
   //    value character string and the prepared assertion value character
   //    string have the same number of characters and corresponding
   //    characters have the same code point.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are case folded in the Map preparation step, and only
   //    Insignificant Space Handling is applied in the Insignificant
   //    Character Handling step.
   //
   //    The LDAP definition for the caseIgnoreIA5Match rule is:
   //
   //       ( 1.3.6.1.4.1.1466.109.114.2 NAME 'caseIgnoreIA5Match'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
   //
   //    The caseIgnoreIA5Match rule is an equality matching rule.
   //
   .oid           =  "1.3.6.1.4.1.1466.109.114.2",
   .name          =  "caseIgnoreIA5Match",
   .desc          =  "caseIgnoreIA5Match",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 1.3.6.1.4.1.1466.109.114.2 NAME 'caseIgnoreIA5Match' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.7",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.8.  caseIgnoreIA5SubstringsMatch
   //
   //    The caseIgnoreIA5SubstringsMatch rule compares an assertion value of
   //    the Substring Assertion syntax to an attribute value of a syntax
   //    (e.g., the IA5 String syntax) whose corresponding ASN.1 type is
   //    IA5String.
   //
   //    The rule evaluates to TRUE if and only if (1) the prepared substrings
   //    of the assertion value match disjoint portions of the prepared
   //    attribute value character string in the order of the substrings in
   //    the assertion value, (2) an <initial> substring, if present, matches
   //    the beginning of the prepared attribute value character string, and
   //    (3) a <final> substring, if present, matches the end of the prepared
   //    attribute value character string.  A prepared substring matches a
   //    portion of the prepared attribute value character string if
   //    corresponding characters have the same code point.
   //
   //    In preparing the attribute value and assertion value substrings for
   //    comparison, characters are case folded in the Map preparation step,
   //    and only Insignificant Space Handling is applied in the Insignificant
   //    Character Handling step.
   //
   //       ( 1.3.6.1.4.1.1466.109.114.3 NAME 'caseIgnoreIA5SubstringsMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )
   //
   //    The caseIgnoreIA5SubstringsMatch rule is a substrings matching rule.
   //
   .oid           =  "1.3.6.1.4.1.1466.109.114.3",
   .name          =  "caseIgnoreIA5SubstringsMatch",
   .desc          =  "caseIgnoreIA5SubstringsMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 1.3.6.1.4.1.1466.109.114.3 NAME 'caseIgnoreIA5SubstringsMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.8",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.9.  caseIgnoreListMatch
   //
   //    The caseIgnoreListMatch rule compares an assertion value that is a
   //    sequence of strings to an attribute value of a syntax (e.g., the
   //
   //    Postal Address syntax) whose corresponding ASN.1 type is a SEQUENCE
   //    OF the DirectoryString ASN.1 type.
   //
   //    The rule evaluates to TRUE if and only if the attribute value and the
   //    assertion value have the same number of strings and corresponding
   //    strings (by position) match according to the caseIgnoreMatch matching
   //    rule.
   //
   //    In [X.520], the assertion syntax for this matching rule is defined to
   //    be:
   //
   //       SEQUENCE OF DirectoryString {ub-match}
   //
   //    That is, it is different from the corresponding type for the Postal
   //    Address syntax.  The choice of the Postal Address syntax for the
   //    assertion syntax of the caseIgnoreListMatch in LDAP should not be
   //    seen as limiting the matching rule to apply only to attributes with
   //    the Postal Address syntax.
   //
   //    The LDAP definition for the caseIgnoreListMatch rule is:
   //
   //       ( 2.5.13.11 NAME 'caseIgnoreListMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.41 )
   //
   //    The caseIgnoreListMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.11",
   .name          =  "caseIgnoreListMatch",
   .desc          =  "caseIgnoreListMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.11 NAME 'caseIgnoreListMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.41 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.9",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.10.  caseIgnoreListSubstringsMatch
   //
   //    The caseIgnoreListSubstringsMatch rule compares an assertion value of
   //    the Substring Assertion syntax to an attribute value of a syntax
   //    (e.g., the Postal Address syntax) whose corresponding ASN.1 type is a
   //    SEQUENCE OF the DirectoryString ASN.1 type.
   //
   //    The rule evaluates to TRUE if and only if the assertion value
   //    matches, per the caseIgnoreSubstringsMatch rule, the character string
   //    formed by concatenating the strings of the attribute value, except
   //    that none of the <initial>, <any>, or <final> substrings of the
   //    assertion value are considered to match a substring of the
   //    concatenated string which spans more than one of the original strings
   //    of the attribute value.
   //
   //    Note that, in terms of the LDAP-specific encoding of the Postal
   //    Address syntax, the concatenated string omits the <DOLLAR> line
   //    separator and the escaping of "\" and "$" characters.
   //
   //    The LDAP definition for the caseIgnoreListSubstringsMatch rule is:
   //
   //       ( 2.5.13.12 NAME 'caseIgnoreListSubstringsMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )
   //
   //    The caseIgnoreListSubstringsMatch rule is a substrings matching rule.
   //
   .oid           =  "2.5.13.12",
   .name          =  "caseIgnoreListSubstringsMatch",
   .desc          =  "caseIgnoreListSubstringsMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.12 NAME 'caseIgnoreListSubstringsMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.10",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.11.  caseIgnoreMatch
   //
   //    The caseIgnoreMatch rule compares an assertion value of the Directory
   //    String syntax to an attribute value of a syntax (e.g., the Directory
   //    String, Printable String, Country String, or Telephone Number syntax)
   //    whose corresponding ASN.1 type is DirectoryString or one of its
   //    alternative string types.
   //
   //    The rule evaluates to TRUE if and only if the prepared attribute
   //    value character string and the prepared assertion value character
   //    string have the same number of characters and corresponding
   //    characters have the same code point.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are case folded in the Map preparation step, and only
   //    Insignificant Space Handling is applied in the Insignificant
   //    Character Handling step.
   //
   //    The LDAP definition for the caseIgnoreMatch rule is:
   //
   //       ( 2.5.13.2 NAME 'caseIgnoreMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
   //
   //    The caseIgnoreMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.2",
   .name          =  "caseIgnoreMatch",
   .desc          =  "caseIgnoreMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.2 NAME 'caseIgnoreMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.11",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.12.  caseIgnoreOrderingMatch
   //
   //    The caseIgnoreOrderingMatch rule compares an assertion value of the
   //    Directory String syntax to an attribute value of a syntax (e.g., the
   //    Directory String, Printable String, Country String, or Telephone
   //    Number syntax) whose corresponding ASN.1 type is DirectoryString or
   //    one of its alternative string types.
   //
   //    The rule evaluates to TRUE if and only if, in the code point
   //    collation order, the prepared attribute value character string
   //    appears earlier than the prepared assertion value character string;
   //    i.e., the attribute value is "less than" the assertion value.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are case folded in the Map preparation step, and only
   //    Insignificant Space Handling is applied in the Insignificant
   //    Character Handling step.
   //
   //    The LDAP definition for the caseIgnoreOrderingMatch rule is:
   //
   //       ( 2.5.13.3 NAME 'caseIgnoreOrderingMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
   //
   //    The caseIgnoreOrderingMatch rule is an ordering matching rule.
   //
   .oid           =  "2.5.13.3",
   .name          =  "caseIgnoreOrderingMatch",
   .desc          =  "caseIgnoreOrderingMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.3 NAME 'caseIgnoreOrderingMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.12",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.13.  caseIgnoreSubstringsMatch
   //
   //    The caseIgnoreSubstringsMatch rule compares an assertion value of the
   //    Substring Assertion syntax to an attribute value of a syntax (e.g.,
   //    the Directory String, Printable String, Country String, or Telephone
   //    Number syntax) whose corresponding ASN.1 type is DirectoryString or
   //    one of its alternative string types.
   //
   //    The rule evaluates to TRUE if and only if (1) the prepared substrings
   //    of the assertion value match disjoint portions of the prepared
   //    attribute value character string in the order of the substrings in
   //    the assertion value, (2) an <initial> substring, if present, matches
   //    the beginning of the prepared attribute value character string, and
   //    (3) a <final> substring, if present, matches the end of the prepared
   //    attribute value character string.  A prepared substring matches a
   //    portion of the prepared attribute value character string if
   //    corresponding characters have the same code point.
   //
   //    In preparing the attribute value and assertion value substrings for
   //    comparison, characters are case folded in the Map preparation step,
   //    and only Insignificant Space Handling is applied in the Insignificant
   //    Character Handling step.
   //
   //    The LDAP definition for the caseIgnoreSubstringsMatch rule is:
   //
   //       ( 2.5.13.4 NAME 'caseIgnoreSubstringsMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )
   //
   //    The caseIgnoreSubstringsMatch rule is a substrings matching rule.
   //
   .oid           =  "2.5.13.4",
   .name          =  "caseIgnoreSubstringsMatch",
   .desc          =  "caseIgnoreSubstringsMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.4 NAME 'caseIgnoreSubstringsMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.13",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.14.  directoryStringFirstComponentMatch
   //
   //    The directoryStringFirstComponentMatch rule compares an assertion
   //    value of the Directory String syntax to an attribute value of a
   //    syntax whose corresponding ASN.1 type is a SEQUENCE with a mandatory
   //    first component of the DirectoryString ASN.1 type.
   //
   //    Note that the assertion syntax of this matching rule differs from the
   //    attribute syntax of attributes for which this is the equality
   //    matching rule.
   //
   //    The rule evaluates to TRUE if and only if the assertion value matches
   //    the first component of the attribute value using the rules of
   //    caseIgnoreMatch.
   //
   //    The LDAP definition for the directoryStringFirstComponentMatch
   //    matching rule is:
   //
   //       ( 2.5.13.31 NAME 'directoryStringFirstComponentMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
   //
   //    The directoryStringFirstComponentMatch rule is an equality matching
   //    rule.  When using directoryStringFirstComponentMatch to compare two
   //    attribute values (of an applicable syntax), an assertion value must
   //    first be derived from one of the attribute values.  An assertion
   //    value can be derived from an attribute value by taking the first
   //    component of that attribute value.
   //
   .oid           =  "2.5.13.31",
   .name          =  "directoryStringFirstComponentMatch",
   .desc          =  "directoryStringFirstComponentMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.31 NAME 'directoryStringFirstComponentMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.14",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.15.  distinguishedNameMatch
   //
   //    The distinguishedNameMatch rule compares an assertion value of the DN
   //    syntax to an attribute value of a syntax (e.g., the DN syntax) whose
   //    corresponding ASN.1 type is DistinguishedName.
   //
   //    The rule evaluates to TRUE if and only if the attribute value and the
   //    assertion value have the same number of relative distinguished names
   //    and corresponding relative distinguished names (by position) are the
   //    same.  A relative distinguished name (RDN) of the assertion value is
   //    the same as an RDN of the attribute value if and only if they have
   //    the same number of attribute value assertions and each attribute
   //    value assertion (AVA) of the first RDN is the same as the AVA of the
   //    second RDN with the same attribute type.  The order of the AVAs is
   //    not significant.  Also note that a particular attribute type may
   //    appear in at most one AVA in an RDN.  Two AVAs with the same
   //    attribute type are the same if their values are equal according to
   //    the equality matching rule of the attribute type.  If one or more of
   //    the AVA comparisons evaluate to Undefined and the remaining AVA
   //    comparisons return TRUE then the distinguishedNameMatch rule
   //    evaluates to Undefined.
   //
   //    The LDAP definition for the distinguishedNameMatch rule is:
   //
   //       ( 2.5.13.1 NAME 'distinguishedNameMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
   //
   //    The distinguishedNameMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.1",
   .name          =  "distinguishedNameMatch",
   .desc          =  "distinguishedNameMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.1 NAME 'distinguishedNameMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.15",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.16.  generalizedTimeMatch
   //
   //    The generalizedTimeMatch rule compares an assertion value of the
   //    Generalized Time syntax to an attribute value of a syntax (e.g., the
   //    Generalized Time syntax) whose corresponding ASN.1 type is
   //    GeneralizedTime.
   //
   //    The rule evaluates to TRUE if and only if the attribute value
   //    represents the same universal coordinated time as the assertion
   //    value.  If a time is specified with the minutes or seconds absent,
   //    then the number of minutes or seconds (respectively) is assumed to be
   //    zero.
   //
   //    The LDAP definition for the generalizedTimeMatch rule is:
   //
   //       ( 2.5.13.27 NAME 'generalizedTimeMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 )
   //
   //    The generalizedTimeMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.27",
   .name          =  "generalizedTimeMatch",
   .desc          =  "generalizedTimeMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.27 NAME 'generalizedTimeMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.16",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.17.  generalizedTimeOrderingMatch
   //
   //    The generalizedTimeOrderingMatch rule compares the time ordering of
   //    an assertion value of the Generalized Time syntax to an attribute
   //    value of a syntax (e.g., the Generalized Time syntax) whose
   //    corresponding ASN.1 type is GeneralizedTime.
   //
   //    The rule evaluates to TRUE if and only if the attribute value
   //    represents a universal coordinated time that is earlier than the
   //    universal coordinated time represented by the assertion value.
   //
   //    The LDAP definition for the generalizedTimeOrderingMatch rule is:
   //
   //       ( 2.5.13.28 NAME 'generalizedTimeOrderingMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 )
   //
   //    The generalizedTimeOrderingMatch rule is an ordering matching rule.
   //
   .oid           =  "2.5.13.28",
   .name          =  "generalizedTimeOrderingMatch",
   .desc          =  "generalizedTimeOrderingMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.28 NAME 'generalizedTimeOrderingMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.17",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.18.  integerFirstComponentMatch
   //
   //    The integerFirstComponentMatch rule compares an assertion value of
   //    the Integer syntax to an attribute value of a syntax (e.g., the DIT
   //    Structure Rule Description syntax) whose corresponding ASN.1 type is
   //    a SEQUENCE with a mandatory first component of the INTEGER ASN.1
   //    type.
   //
   //    Note that the assertion syntax of this matching rule differs from the
   //    attribute syntax of attributes for which this is the equality
   //    matching rule.
   //
   //    The rule evaluates to TRUE if and only if the assertion value and the
   //    first component of the attribute value are the same integer value.
   //
   //    The LDAP definition for the integerFirstComponentMatch matching rule
   //    is:
   //
   //       ( 2.5.13.29 NAME 'integerFirstComponentMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )
   //
   //    The integerFirstComponentMatch rule is an equality matching rule.
   //    When using integerFirstComponentMatch to compare two attribute values
   //    (of an applicable syntax), an assertion value must first be derived
   //    from one of the attribute values.  An assertion value can be derived
   //    from an attribute value by taking the first component of that
   //    attribute value.
   //
   .oid           =  "2.5.13.29",
   .name          =  "integerFirstComponentMatch",
   .desc          =  "integerFirstComponentMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.29 NAME 'integerFirstComponentMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.18",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.19.  integerMatch
   //
   //    The integerMatch rule compares an assertion value of the Integer
   //    syntax to an attribute value of a syntax (e.g., the Integer syntax)
   //    whose corresponding ASN.1 type is INTEGER.
   //
   //    The rule evaluates to TRUE if and only if the attribute value and the
   //    assertion value are the same integer value.
   //
   //    The LDAP definition for the integerMatch matching rule is:
   //
   //       ( 2.5.13.14 NAME 'integerMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )
   //
   //    The integerMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.14",
   .name          =  "integerMatch",
   .desc          =  "integerMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.14 NAME 'integerMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.19",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.20.  integerOrderingMatch
   //
   //    The integerOrderingMatch rule compares an assertion value of the
   //    Integer syntax to an attribute value of a syntax (e.g., the Integer
   //    syntax) whose corresponding ASN.1 type is INTEGER.
   //
   //    The rule evaluates to TRUE if and only if the integer value of the
   //    attribute value is less than the integer value of the assertion
   //    value.
   //
   //    The LDAP definition for the integerOrderingMatch matching rule is:
   //
   //       ( 2.5.13.15 NAME 'integerOrderingMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )
   //
   //    The integerOrderingMatch rule is an ordering matching rule.
   //
   .oid           =  "2.5.13.15",
   .name          =  "integerOrderingMatch",
   .desc          =  "integerOrderingMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.15 NAME 'integerOrderingMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.20",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.21.  keywordMatch
   //
   //    The keywordMatch rule compares an assertion value of the Directory
   //    String syntax to an attribute value of a syntax (e.g., the Directory
   //    String syntax) whose corresponding ASN.1 type is DirectoryString.
   //
   //    The rule evaluates to TRUE if and only if the assertion value
   //    character string matches any keyword in the attribute value.  The
   //    identification of keywords in the attribute value and the exactness
   //    of the match are both implementation specific.
   //
   //    The LDAP definition for the keywordMatch rule is:
   //
   //       ( 2.5.13.33 NAME 'keywordMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
   //
   .oid           =  "2.5.13.33",
   .name          =  "integerOrderingMatch",
   .desc          =  "integerOrderingMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.33 NAME 'keywordMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.21",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.22.  numericStringMatch
   //
   //    The numericStringMatch rule compares an assertion value of the
   //    Numeric String syntax to an attribute value of a syntax (e.g., the
   //    Numeric String syntax) whose corresponding ASN.1 type is
   //    NumericString.
   //
   //    The rule evaluates to TRUE if and only if the prepared attribute
   //    value character string and the prepared assertion value character
   //    string have the same number of characters and corresponding
   //    characters have the same code point.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are not case folded in the Map preparation step, and only
   //    numericString Insignificant Character Handling is applied in the
   //    Insignificant Character Handling step.
   //
   //    The LDAP definition for the numericStringMatch matching rule is:
   //
   //       ( 2.5.13.8 NAME 'numericStringMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.36 )
   //
   //    The numericStringMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.8",
   .name          =  "numericStringMatch",
   .desc          =  "numericStringMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.8 NAME 'numericStringMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.36 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.22",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.23.  numericStringOrderingMatch
   //
   //    The numericStringOrderingMatch rule compares an assertion value of
   //    the Numeric String syntax to an attribute value of a syntax (e.g.,
   //    the Numeric String syntax) whose corresponding ASN.1 type is
   //    NumericString.
   //
   //    The rule evaluates to TRUE if and only if, in the code point
   //    collation order, the prepared attribute value character string
   //    appears earlier than the prepared assertion value character string;
   //    i.e., the attribute value is "less than" the assertion value.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are not case folded in the Map preparation step, and only
   //    numericString Insignificant Character Handling is applied in the
   //    Insignificant Character Handling step.
   //
   //    The rule is identical to the caseIgnoreOrderingMatch rule except that
   //    all space characters are skipped during comparison (case is
   //    irrelevant as the characters are numeric).
   //
   //    The LDAP definition for the numericStringOrderingMatch matching rule
   //    is:
   //
   //       ( 2.5.13.9 NAME 'numericStringOrderingMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.36 )
   //
   //    The numericStringOrderingMatch rule is an ordering matching rule.
   //
   .oid           =  "2.5.13.9",
   .name          =  "numericStringOrderingMatch",
   .desc          =  "numericStringOrderingMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.9 NAME 'numericStringOrderingMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.36 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.23",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.24.  numericStringSubstringsMatch
   //
   //    The numericStringSubstringsMatch rule compares an assertion value of
   //    the Substring Assertion syntax to an attribute value of a syntax
   //    (e.g., the Numeric String syntax) whose corresponding ASN.1 type is
   //    NumericString.
   //
   //    The rule evaluates to TRUE if and only if (1) the prepared substrings
   //    of the assertion value match disjoint portions of the prepared
   //    attribute value character string in the order of the substrings in
   //    the assertion value, (2) an <initial> substring, if present, matches
   //    the beginning of the prepared attribute value character string, and
   //    (3) a <final> substring, if present, matches the end of the prepared
   //    attribute value character string.  A prepared substring matches a
   //    portion of the prepared attribute value character string if
   //    corresponding characters have the same code point.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are not case folded in the Map preparation step, and only
   //    numericString Insignificant Character Handling is applied in the
   //    Insignificant Character Handling step.
   //
   //    The LDAP definition for the numericStringSubstringsMatch matching
   //    rule is:
   //
   //       ( 2.5.13.10 NAME 'numericStringSubstringsMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )
   //
   //    The numericStringSubstringsMatch rule is a substrings matching rule.
   //
   .oid           =  "2.5.13.10",
   .name          =  "numericStringSubstringsMatch",
   .desc          =  "numericStringSubstringsMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.10 NAME 'numericStringSubstringsMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.24",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.25.  objectIdentifierFirstComponentMatch
   //
   //    The objectIdentifierFirstComponentMatch rule compares an assertion
   //    value of the OID syntax to an attribute value of a syntax (e.g., the
   //    Attribute Type Description, DIT Content Rule Description, LDAP Syntax
   //    Description, Matching Rule Description, Matching Rule Use
   //    Description, Name Form Description, or Object Class Description
   //    syntax) whose corresponding ASN.1 type is a SEQUENCE with a mandatory
   //    first component of the OBJECT IDENTIFIER ASN.1 type.
   //
   //    Note that the assertion syntax of this matching rule differs from the
   //    attribute syntax of attributes for which this is the equality
   //    matching rule.
   //
   //    The rule evaluates to TRUE if and only if the assertion value matches
   //    the first component of the attribute value using the rules of
   //    objectIdentifierMatch.
   //
   //    The LDAP definition for the objectIdentifierFirstComponentMatch
   //    matching rule is:
   //
   //       ( 2.5.13.30 NAME 'objectIdentifierFirstComponentMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.38 )
   //
   //    The objectIdentifierFirstComponentMatch rule is an equality matching
   //    rule.  When using objectIdentifierFirstComponentMatch to compare two
   //    attribute values (of an applicable syntax), an assertion value must
   //    first be derived from one of the attribute values.  An assertion
   //    value can be derived from an attribute value by taking the first
   //    component of that attribute value.
   //
   .oid           =  "2.5.13.30",
   .name          =  "objectIdentifierFirstComponentMatch",
   .desc          =  "objectIdentifierFirstComponentMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.30 NAME 'objectIdentifierFirstComponentMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.38 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.25",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.26.  objectIdentifierMatch
   //
   //    The objectIdentifierMatch rule compares an assertion value of the OID
   //    syntax to an attribute value of a syntax (e.g., the OID syntax) whose
   //    corresponding ASN.1 type is OBJECT IDENTIFIER.
   //
   //    The rule evaluates to TRUE if and only if the assertion value and the
   //    attribute value represent the same object identifier; that is, the
   //    same sequence of integers, whether represented explicitly in the
   //    <numericoid> form of <oid> or implicitly in the <descr> form (see
   //    [RFC4512]).
   //
   //    If an LDAP client supplies an assertion value in the <descr> form and
   //    the chosen descriptor is not recognized by the server, then the
   //    objectIdentifierMatch rule evaluates to Undefined.
   //
   //    The LDAP definition for the objectIdentifierMatch matching rule is:
   //
   //       ( 2.5.13.0 NAME 'objectIdentifierMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.38 )
   //
   //    The objectIdentifierMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.0",
   .name          =  "objectIdentifierMatch",
   .desc          =  "objectIdentifierMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.0 NAME 'objectIdentifierMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.38 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.26",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.27.  octetStringMatch
   //
   //    The octetStringMatch rule compares an assertion value of the Octet
   //    String syntax to an attribute value of a syntax (e.g., the Octet
   //    String or JPEG syntax) whose corresponding ASN.1 type is the OCTET
   //    STRING ASN.1 type.
   //
   //    The rule evaluates to TRUE if and only if the attribute value and the
   //    assertion value are the same length and corresponding octets (by
   //    position) are the same.
   //
   //    The LDAP definition for the octetStringMatch matching rule is:
   //
   //       ( 2.5.13.17 NAME 'octetStringMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 )
   //
   //    The octetStringMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.17",
   .name          =  "octetStringMatch",
   .desc          =  "octetStringMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.17 NAME 'octetStringMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.27",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.28.  octetStringOrderingMatch
   //
   //    The octetStringOrderingMatch rule compares an assertion value of the
   //    Octet String syntax to an attribute value of a syntax (e.g., the
   //    Octet String or JPEG syntax) whose corresponding ASN.1 type is the
   //    OCTET STRING ASN.1 type.
   //
   //    The rule evaluates to TRUE if and only if the attribute value appears
   //    earlier in the collation order than the assertion value.  The rule
   //    compares octet strings from the first octet to the last octet, and
   //    from the most significant bit to the least significant bit within the
   //    octet.  The first occurrence of a different bit determines the
   //    ordering of the strings.  A zero bit precedes a one bit.  If the
   //    strings contain different numbers of octets but the longer string is
   //    identical to the shorter string up to the length of the shorter
   //    string, then the shorter string precedes the longer string.
   //
   //    The LDAP definition for the octetStringOrderingMatch matching rule
   //    is:
   //
   //       ( 2.5.13.18 NAME 'octetStringOrderingMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 )
   //
   //    The octetStringOrderingMatch rule is an ordering matching rule.
   //
   .oid           =  "2.5.13.18",
   .name          =  "octetStringOrderingMatch",
   .desc          =  "octetStringOrderingMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.18 NAME 'octetStringOrderingMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.28",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.29.  telephoneNumberMatch
   //
   //    The telephoneNumberMatch rule compares an assertion value of the
   //    Telephone Number syntax to an attribute value of a syntax (e.g., the
   //    Telephone Number syntax) whose corresponding ASN.1 type is a
   //    PrintableString representing a telephone number.
   //
   //    The rule evaluates to TRUE if and only if the prepared attribute
   //    value character string and the prepared assertion value character
   //    string have the same number of characters and corresponding
   //    characters have the same code point.
   //
   //    In preparing the attribute value and assertion value for comparison,
   //    characters are case folded in the Map preparation step, and only
   //    telephoneNumber Insignificant Character Handling is applied in the
   //    Insignificant Character Handling step.
   //
   //    The LDAP definition for the telephoneNumberMatch matching rule is:
   //
   //       ( 2.5.13.20 NAME 'telephoneNumberMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.50 )
   //
   //    The telephoneNumberMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.20",
   .name          =  "telephoneNumberMatch",
   .desc          =  "telephoneNumberMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.20 NAME 'telephoneNumberMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.50 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.29",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.30.  telephoneNumberSubstringsMatch
   //
   //    The telephoneNumberSubstringsMatch rule compares an assertion value
   //    of the Substring Assertion syntax to an attribute value of a syntax
   //    (e.g., the Telephone Number syntax) whose corresponding ASN.1 type is
   //    a PrintableString representing a telephone number.
   //
   //    The rule evaluates to TRUE if and only if (1) the prepared substrings
   //    of the assertion value match disjoint portions of the prepared
   //    attribute value character string in the order of the substrings in
   //    the assertion value, (2) an <initial> substring, if present, matches
   //    the beginning of the prepared attribute value character string, and
   //    (3) a <final> substring, if present, matches the end of the prepared
   //    attribute value character string.  A prepared substring matches a
   //    portion of the prepared attribute value character string if
   //    corresponding characters have the same code point.
   //
   //    In preparing the attribute value and assertion value substrings for
   //    comparison, characters are case folded in the Map preparation step,
   //    and only telephoneNumber Insignificant Character Handling is applied
   //    in the Insignificant Character Handling step.
   //
   //    The LDAP definition for the telephoneNumberSubstringsMatch matching
   //    rule is:
   //
   //       ( 2.5.13.21 NAME 'telephoneNumberSubstringsMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )
   //
   //    The telephoneNumberSubstringsMatch rule is a substrings matching
   //    rule.
   //
   .oid           =  "2.5.13.21",
   .name          =  "telephoneNumberSubstringsMatch",
   .desc          =  "telephoneNumberSubstringsMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.21 NAME 'telephoneNumberSubstringsMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.58 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.30",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.31.  uniqueMemberMatch
   //
   //    The uniqueMemberMatch rule compares an assertion value of the Name
   //    And Optional UID syntax to an attribute value of a syntax (e.g., the
   //    Name And Optional UID syntax) whose corresponding ASN.1 type is
   //    NameAndOptionalUID.
   //
   //    The rule evaluates to TRUE if and only if the <distinguishedName>
   //    components of the assertion value and attribute value match according
   //    to the distinguishedNameMatch rule and either, (1) the <BitString>
   //    component is absent from both the attribute value and assertion
   //    value, or (2) the <BitString> component is present in both the
   //    attribute value and the assertion value and the <BitString> component
   //    of the assertion value matches the <BitString> component of the
   //    attribute value according to the bitStringMatch rule.
   //
   //    Note that this matching rule has been altered from its description in
   //    X.520 [X.520] in order to make the matching rule commutative.  Server
   //    implementors should consider using the original X.520 semantics
   //    (where the matching was less exact) for approximate matching of
   //    attributes with uniqueMemberMatch as the equality matching rule.
   //
   //    The LDAP definition for the uniqueMemberMatch matching rule is:
   //
   //       ( 2.5.13.23 NAME 'uniqueMemberMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.34 )
   //
   //    The uniqueMemberMatch rule is an equality matching rule.
   //
   .oid           =  "2.5.13.23",
   .name          =  "uniqueMemberMatch",
   .desc          =  "uniqueMemberMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.23 NAME 'uniqueMemberMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.34 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.31",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};



{
   //
   // RFC 4517           LDAP: Syntaxes and Matching Rules           June 2006
   //
   // 4.2.32.  wordMatch
   //
   //    The wordMatch rule compares an assertion value of the Directory
   //    String syntax to an attribute value of a syntax (e.g., the Directory
   //    String syntax) whose corresponding ASN.1 type is DirectoryString.
   //
   //    The rule evaluates to TRUE if and only if the assertion value word
   //    matches, according to the semantics of caseIgnoreMatch, any word in
   //    the attribute value.  The precise definition of a word is
   //    implementation specific.
   //
   //    The LDAP definition for the wordMatch rule is:
   //
   //       ( 2.5.13.32 NAME 'wordMatch'
   //          SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )
   //
   .oid           =  "2.5.13.32",
   .name          =  "wordMatch",
   .desc          =  "wordMatch",
   .type          =  LDAPSCHEMA_MATCHINGRULE,
   .def           =  "( 2.5.13.32 NAME 'wordMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
   .spec          =  "RFC 4517: LDAP: Syntaxes and Matching Rules",
   .spec_type     =  LDAPSCHEMA_SPEC_RFC,
   .spec_name     =  "4517",
   .spec_section  =  "4.2.32",
   .spec_source   =  NULL,
   .spec_vendor   =  "IETF",
};


// end of OID spec file
